<?php
/**
 * ApiApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Aspose.PDF for AWS
 *
 * Aspose.Pdf for AWS provides a comprehensive set of endpoints for various PDF-related tasks, enabling efficient document processing and manipulation. Users can retrieve processing status, download files, manage file locks, parse documents, redact sensitive information, convert between formats, merge files, add watermarks, perform text searches, and much more. With endpoints for tasks like electronic signing, document comparison, and form filling, the API offers extensive functionality to cater to diverse PDF requirements.
 *
 * OpenAPI spec version: v1
 * Contact: sales@aspose.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.60
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Stream;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ApiApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ApiApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation pdfWebapiAddnumberPost
     *
     * Add Page Numbers to Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiAddnumberPost($files = null, $document_password = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        list($response) = $this->pdfWebapiAddnumberPostWithHttpInfo($files, $document_password, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format);
        return $response;
    }

    /**
     * Operation pdfWebapiAddnumberPostWithHttpInfo
     *
     * Add Page Numbers to Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiAddnumberPostWithHttpInfo($files = null, $document_password = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiAddnumberPostRequest($files, $document_password, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiAddnumberPostAsync
     *
     * Add Page Numbers to Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiAddnumberPostAsync($files = null, $document_password = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        return $this->pdfWebapiAddnumberPostAsyncWithHttpInfo($files, $document_password, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiAddnumberPostAsyncWithHttpInfo
     *
     * Add Page Numbers to Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiAddnumberPostAsyncWithHttpInfo($files = null, $document_password = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiAddnumberPostRequest($files, $document_password, $v_alignment, $h_alignment, $starting_number, $s_number, $f_number, $margin, $font_size, $format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiAddnumberPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\PageNumberVerticalAlign $v_alignment The vertical alignment of the page numbers. (optional)
     * @param  \Swagger\Client\Model\PageNumberHorizontalAlign $h_alignment The horizontal alignment of the page numbers. (optional)
     * @param  int $starting_number The starting number for the page numbers. (optional)
     * @param  int $s_number The number of the first page to start numbering from. (optional)
     * @param  int $f_number The number of the last page to end numbering at. (optional)
     * @param  int $margin The margin around the page numbers. (optional)
     * @param  int $font_size The font size of the page numbers. (optional)
     * @param  string $format The format of the page numbers. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiAddnumberPostRequest($files = null, $document_password = null, $v_alignment = null, $h_alignment = null, $starting_number = null, $s_number = null, $f_number = null, $margin = null, $font_size = null, $format = null)
    {

        $resourcePath = '/pdf/webapi/addnumber';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($v_alignment !== null) {
            $queryParams['vAlignment'] = ObjectSerializer::toQueryValue($v_alignment, null);
        }
        // query params
        if ($h_alignment !== null) {
            $queryParams['hAlignment'] = ObjectSerializer::toQueryValue($h_alignment, null);
        }
        // query params
        if ($starting_number !== null) {
            $queryParams['startingNumber'] = ObjectSerializer::toQueryValue($starting_number, 'int32');
        }
        // query params
        if ($s_number !== null) {
            $queryParams['sNumber'] = ObjectSerializer::toQueryValue($s_number, 'int32');
        }
        // query params
        if ($f_number !== null) {
            $queryParams['fNumber'] = ObjectSerializer::toQueryValue($f_number, 'int32');
        }
        // query params
        if ($margin !== null) {
            $queryParams['margin'] = ObjectSerializer::toQueryValue($margin, 'int32');
        }
        // query params
        if ($font_size !== null) {
            $queryParams['fontSize'] = ObjectSerializer::toQueryValue($font_size, 'int32');
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiChangeFontsPost
     *
     * Change Fonts in Provided Files.
     *
     * @param  string $font_replacements_json font_replacements_json (optional)
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiChangeFontsPost($font_replacements_json = null, $files = null, $document_password = null)
    {
        list($response) = $this->pdfWebapiChangeFontsPostWithHttpInfo($font_replacements_json, $files, $document_password);
        return $response;
    }

    /**
     * Operation pdfWebapiChangeFontsPostWithHttpInfo
     *
     * Change Fonts in Provided Files.
     *
     * @param  string $font_replacements_json (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiChangeFontsPostWithHttpInfo($font_replacements_json = null, $files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiChangeFontsPostRequest($font_replacements_json, $files, $document_password);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiChangeFontsPostAsync
     *
     * Change Fonts in Provided Files.
     *
     * @param  string $font_replacements_json (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiChangeFontsPostAsync($font_replacements_json = null, $files = null, $document_password = null)
    {
        return $this->pdfWebapiChangeFontsPostAsyncWithHttpInfo($font_replacements_json, $files, $document_password)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiChangeFontsPostAsyncWithHttpInfo
     *
     * Change Fonts in Provided Files.
     *
     * @param  string $font_replacements_json (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiChangeFontsPostAsyncWithHttpInfo($font_replacements_json = null, $files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiChangeFontsPostRequest($font_replacements_json, $files, $document_password);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiChangeFontsPost'
     *
     * @param  string $font_replacements_json (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiChangeFontsPostRequest($font_replacements_json = null, $files = null, $document_password = null)
    {

        $resourcePath = '/pdf/webapi/change-fonts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($font_replacements_json !== null) {
            $formParams['fontReplacementsJson'] = ObjectSerializer::toFormValue($font_replacements_json);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiComparisonPost
     *
     * Compare documents text.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiComparisonPost($files = null, $document_password = null)
    {
        list($response) = $this->pdfWebapiComparisonPostWithHttpInfo($files, $document_password);
        return $response;
    }

    /**
     * Operation pdfWebapiComparisonPostWithHttpInfo
     *
     * Compare documents text.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiComparisonPostWithHttpInfo($files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiComparisonPostRequest($files, $document_password);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiComparisonPostAsync
     *
     * Compare documents text.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiComparisonPostAsync($files = null, $document_password = null)
    {
        return $this->pdfWebapiComparisonPostAsyncWithHttpInfo($files, $document_password)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiComparisonPostAsyncWithHttpInfo
     *
     * Compare documents text.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiComparisonPostAsyncWithHttpInfo($files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiComparisonPostRequest($files, $document_password);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiComparisonPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiComparisonPostRequest($files = null, $document_password = null)
    {

        $resourcePath = '/pdf/webapi/comparison';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiCompressPost
     *
     * Compress Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiCompressPost($files = null, $document_password = null, $compress_type = null)
    {
        list($response) = $this->pdfWebapiCompressPostWithHttpInfo($files, $document_password, $compress_type);
        return $response;
    }

    /**
     * Operation pdfWebapiCompressPostWithHttpInfo
     *
     * Compress Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiCompressPostWithHttpInfo($files = null, $document_password = null, $compress_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCompressPostRequest($files, $document_password, $compress_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();

            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiCompressPostAsync
     *
     * Compress Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCompressPostAsync($files = null, $document_password = null, $compress_type = null)
    {
        return $this->pdfWebapiCompressPostAsyncWithHttpInfo($files, $document_password, $compress_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiCompressPostAsyncWithHttpInfo
     *
     * Compress Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCompressPostAsyncWithHttpInfo($files = null, $document_password = null, $compress_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCompressPostRequest($files, $document_password, $compress_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiCompressPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\CompressType $compress_type The level of compression to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiCompressPostRequest($files = null, $document_password = null, $compress_type = null)
    {

        $resourcePath = '/pdf/webapi/compress';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($compress_type !== null) {
            $queryParams['compressType'] = ObjectSerializer::toQueryValue($compress_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        $request =  new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiConvertPost
     *
     * Convert Document to Another Format.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiConvertPost($files = null, $document_password = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        list($response) = $this->pdfWebapiConvertPostWithHttpInfo($files, $document_password, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator);
        return $response;
    }

    /**
     * Operation pdfWebapiConvertPostWithHttpInfo
     *
     * Convert Document to Another Format.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiConvertPostWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertPostRequest($files, $document_password, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiConvertPostAsync
     *
     * Convert Document to Another Format.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertPostAsync($files = null, $document_password = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        return $this->pdfWebapiConvertPostAsyncWithHttpInfo($files, $document_password, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiConvertPostAsyncWithHttpInfo
     *
     * Convert Document to Another Format.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertPostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertPostRequest($files, $document_password, $input_type, $output_type, $xml_type, $xml_tag, $font_sise, $is_to_single, $separator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiConvertPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\XmlType $xml_type The type of XML conversion to perform, if applicable. (optional)
     * @param  string $xml_tag The XML tag to use for conversion, if applicable. (optional)
     * @param  int $font_sise (optional)
     * @param  bool $is_to_single Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param  string $separator The separator to use when converting, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiConvertPostRequest($files = null, $document_password = null, $input_type = null, $output_type = null, $xml_type = null, $xml_tag = null, $font_sise = null, $is_to_single = null, $separator = null)
    {

        $resourcePath = '/pdf/webapi/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($xml_type !== null) {
            $queryParams['xmlType'] = ObjectSerializer::toQueryValue($xml_type, null);
        }
        // query params
        if ($xml_tag !== null) {
            $queryParams['xmlTag'] = ObjectSerializer::toQueryValue($xml_tag, null);
        }
        // query params
        if ($font_sise !== null) {
            $queryParams['fontSise'] = ObjectSerializer::toQueryValue($font_sise, 'int32');
        }
        // query params
        if ($is_to_single !== null) {
            $queryParams['isToSingle'] = ObjectSerializer::toQueryValue($is_to_single, null);
        }
        // query params
        if ($separator !== null) {
            $queryParams['separator'] = ObjectSerializer::toQueryValue($separator, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiConvertWebpagePost
     *
     * Convert Web Page to Document.
     *
     * @param  string $web_page web_page (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiConvertWebpagePost($web_page = null, $document_password = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiConvertWebpagePostWithHttpInfo($web_page, $document_password, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiConvertWebpagePostWithHttpInfo
     *
     * Convert Web Page to Document.
     *
     * @param  string $web_page (optional)
     * @param  string $document_password (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiConvertWebpagePostWithHttpInfo($web_page = null, $document_password = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertWebpagePostRequest($web_page, $document_password, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiConvertWebpagePostAsync
     *
     * Convert Web Page to Document.
     *
     * @param  string $web_page (optional)
     * @param  string $document_password (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertWebpagePostAsync($web_page = null, $document_password = null, $output_type = null)
    {
        return $this->pdfWebapiConvertWebpagePostAsyncWithHttpInfo($web_page, $document_password, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiConvertWebpagePostAsyncWithHttpInfo
     *
     * Convert Web Page to Document.
     *
     * @param  string $web_page (optional)
     * @param  string $document_password (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiConvertWebpagePostAsyncWithHttpInfo($web_page = null, $document_password = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiConvertWebpagePostRequest($web_page, $document_password, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiConvertWebpagePost'
     *
     * @param  string $web_page (optional)
     * @param  string $document_password (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiConvertWebpagePostRequest($web_page = null, $document_password = null, $output_type = null)
    {

        $resourcePath = '/pdf/webapi/convert-webpage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($web_page !== null) {
            $formParams['webPage'] = ObjectSerializer::toFormValue($web_page);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
//                if (isset($formParams['files']) && is_array($formParams['files'])) {
//
//                    $multipartContents = [];
//                    foreach ($formParams['files'] as $file) {
//                        $filesAddedCount++;
//                        if (is_string($file) && file_exists($file) && is_readable($file)) {
//                            $contentType = mime_content_type($file);
//                            $fileResource = fopen($file, 'r');
//
//
//                            $multipartContents[] = [
//                                'name' => 'files[]',
//                                'contents' => new Stream($fileResource),
//                                'filename' => basename($file),
//                                'headers' => [
//                                    'Content-Type' => $contentType,
//                                    'Content-Length' => filesize($file),
//                                ]
//                            ];
//                        }
//                    }
//
//                    // for HTTP post (form)
//                    $httpBody = new MultipartStream($multipartContents);
//                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

//        if ($multipart) {
//            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
//            $headers['Content-Type'] = $contentTypeHeader;
//        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiCropPost
     *
     * Crop Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiCropPost($files = null, $document_password = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiCropPostWithHttpInfo($files, $document_password, $input_type, $top, $right, $bottom, $left, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiCropPostWithHttpInfo
     *
     * Crop Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiCropPostWithHttpInfo($files = null, $document_password = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCropPostRequest($files, $document_password, $input_type, $top, $right, $bottom, $left, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiCropPostAsync
     *
     * Crop Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCropPostAsync($files = null, $document_password = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        return $this->pdfWebapiCropPostAsyncWithHttpInfo($files, $document_password, $input_type, $top, $right, $bottom, $left, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiCropPostAsyncWithHttpInfo
     *
     * Crop Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiCropPostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiCropPostRequest($files, $document_password, $input_type, $top, $right, $bottom, $left, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiCropPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  int $top The number of pixels to crop from the top. (optional)
     * @param  int $right The number of pixels to crop from the right. (optional)
     * @param  int $bottom The number of pixels to crop from the bottom. (optional)
     * @param  int $left The number of pixels to crop from the left. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiCropPostRequest($files = null, $document_password = null, $input_type = null, $top = null, $right = null, $bottom = null, $left = null, $output_type = null)
    {

        $resourcePath = '/pdf/webapi/crop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($top !== null) {
            $queryParams['top'] = ObjectSerializer::toQueryValue($top, 'int32');
        }
        // query params
        if ($right !== null) {
            $queryParams['right'] = ObjectSerializer::toQueryValue($right, 'int32');
        }
        // query params
        if ($bottom !== null) {
            $queryParams['bottom'] = ObjectSerializer::toQueryValue($bottom, 'int32');
        }
        // query params
        if ($left !== null) {
            $queryParams['left'] = ObjectSerializer::toQueryValue($left, 'int32');
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiDownloadIdGet
     *
     * File download.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function pdfWebapiDownloadIdGet($id, $file = null)
    {
        $this->pdfWebapiDownloadIdGetWithHttpInfo($id, $file);
    }

    /**
     * Operation pdfWebapiDownloadIdGetWithHttpInfo
     *
     * File download.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiDownloadIdGetWithHttpInfo($id, $file = null)
    {
        $returnType = '';
        $request = $this->pdfWebapiDownloadIdGetRequest($id, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiDownloadIdGetAsync
     *
     * File download.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiDownloadIdGetAsync($id, $file = null)
    {
        return $this->pdfWebapiDownloadIdGetAsyncWithHttpInfo($id, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiDownloadIdGetAsyncWithHttpInfo
     *
     * File download.
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiDownloadIdGetAsyncWithHttpInfo($id, $file = null)
    {
        $returnType = '';
        $request = $this->pdfWebapiDownloadIdGetRequest($id, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiDownloadIdGet'
     *
     * @param  string $id The id of the processing to download. (required)
     * @param  string $file The name of the file to download. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiDownloadIdGetRequest($id, $file = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiDownloadIdGet'
            );
        }

        $resourcePath = '/pdf/webapi/download/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file !== null) {
            $queryParams['file'] = ObjectSerializer::toQueryValue($file, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiEsignPost
     *
     * Sign Document with Certificate.
     *
     * @param  string $passw passw (optional)
     * @param  string $initials initials (optional)
     * @param  string $invite invite (optional)
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiEsignPost($passw = null, $initials = null, $invite = null, $files = null, $document_password = null, $input_type = null)
    {
        list($response) = $this->pdfWebapiEsignPostWithHttpInfo($passw, $initials, $invite, $files, $document_password, $input_type);
        return $response;
    }

    /**
     * Operation pdfWebapiEsignPostWithHttpInfo
     *
     * Sign Document with Certificate.
     *
     * @param  string $passw (optional)
     * @param  string $initials (optional)
     * @param  string $invite (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiEsignPostWithHttpInfo($passw = null, $initials = null, $invite = null, $files = null, $document_password = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiEsignPostRequest($passw, $initials, $invite, $files, $document_password, $input_type);

//        echo "Request: \n";
//        print_r($request);
//        echo "\n";

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiEsignPostAsync
     *
     * Sign Document with Certificate.
     *
     * @param  string $passw (optional)
     * @param  string $initials (optional)
     * @param  string $invite (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiEsignPostAsync($passw = null, $initials = null, $invite = null, $files = null, $document_password = null, $input_type = null)
    {
        return $this->pdfWebapiEsignPostAsyncWithHttpInfo($passw, $initials, $invite, $files, $document_password, $input_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiEsignPostAsyncWithHttpInfo
     *
     * Sign Document with Certificate.
     *
     * @param  string $passw (optional)
     * @param  string $initials (optional)
     * @param  string $invite (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiEsignPostAsyncWithHttpInfo($passw = null, $initials = null, $invite = null, $files = null, $document_password = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiEsignPostRequest($passw, $initials, $invite, $files, $document_password, $input_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiEsignPost'
     *
     * @param  string $passw (optional)
     * @param  string $initials (optional)
     * @param  string $invite (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiEsignPostRequest($passw = null, $initials = null, $invite = null, $files = null, $document_password = null, $input_type = null)
    {

        $resourcePath = '/pdf/webapi/esign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }


        // form params
        if ($passw !== null) {
            $formParams['passw'] = ObjectSerializer::toFormValue($passw);
        }
        // form params
        if ($initials !== null) {
            $formParams['initials'] = ObjectSerializer::toFormValue($initials);
        }
        // form params
        if ($invite !== null) {
            $formParams['invite'] = ObjectSerializer::toFormValue($invite);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        echo "URL\n".$resourcePath . ($query ? "?{$query}" : '')."\n";

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiExtractPost
     *
     * Extract Tables from Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiExtractPost($files = null, $document_password = null, $input_type = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiExtractPostWithHttpInfo($files, $document_password, $input_type, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiExtractPostWithHttpInfo
     *
     * Extract Tables from Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiExtractPostWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiExtractPostRequest($files, $document_password, $input_type, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiExtractPostAsync
     *
     * Extract Tables from Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiExtractPostAsync($files = null, $document_password = null, $input_type = null, $output_type = null)
    {
        return $this->pdfWebapiExtractPostAsyncWithHttpInfo($files, $document_password, $input_type, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiExtractPostAsyncWithHttpInfo
     *
     * Extract Tables from Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiExtractPostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiExtractPostRequest($files, $document_password, $input_type, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiExtractPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiExtractPostRequest($files = null, $document_password = null, $input_type = null, $output_type = null)
    {

        $resourcePath = '/pdf/webapi/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiGifPost
     *
     * Make GIF.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiGifPost($files = null, $document_password = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        list($response) = $this->pdfWebapiGifPostWithHttpInfo($files, $document_password, $keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times);
        return $response;
    }

    /**
     * Operation pdfWebapiGifPostWithHttpInfo
     *
     * Make GIF.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiGifPostWithHttpInfo($files = null, $document_password = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiGifPostRequest($files, $document_password, $keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiGifPostAsync
     *
     * Make GIF.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiGifPostAsync($files = null, $document_password = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        return $this->pdfWebapiGifPostAsyncWithHttpInfo($files, $document_password, $keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiGifPostAsyncWithHttpInfo
     *
     * Make GIF.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiGifPostAsyncWithHttpInfo($files = null, $document_password = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiGifPostRequest($files, $document_password, $keep_images_as_is, $resize_to_image, $streched, $width, $height, $frame_times);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiGifPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  bool $keep_images_as_is Indicates whether the images should be kept as is. (optional)
     * @param  int $resize_to_image The index of the image to resize the other images to. (optional)
     * @param  bool $streched (optional)
     * @param  int $width The width of the GIF. (optional)
     * @param  int $height The height of the GIF. (optional)
     * @param  string $frame_times The times for each frame in the GIF. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiGifPostRequest($files = null, $document_password = null, $keep_images_as_is = null, $resize_to_image = null, $streched = null, $width = null, $height = null, $frame_times = null)
    {

        $resourcePath = '/pdf/webapi/gif';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($keep_images_as_is !== null) {
            $queryParams['keepImagesAsIs'] = ObjectSerializer::toQueryValue($keep_images_as_is, null);
        }
        // query params
        if ($resize_to_image !== null) {
            $queryParams['resizeToImage'] = ObjectSerializer::toQueryValue($resize_to_image, 'int32');
        }
        // query params
        if ($streched !== null) {
            $queryParams['streched'] = ObjectSerializer::toQueryValue($streched, null);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width, 'int32');
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height, 'int32');
        }
        // query params
        if ($frame_times !== null) {
            $queryParams['frameTimes'] = ObjectSerializer::toQueryValue($frame_times, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiHashPost
     *
     * Calculate Document Hash.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiHashPost($files = null, $document_password = null, $input_type = null, $output_type = null, $alg = null)
    {
        list($response) = $this->pdfWebapiHashPostWithHttpInfo($files, $document_password, $input_type, $output_type, $alg);
        return $response;
    }

    /**
     * Operation pdfWebapiHashPostWithHttpInfo
     *
     * Calculate Document Hash.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiHashPostWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $alg = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiHashPostRequest($files, $document_password, $input_type, $output_type, $alg);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiHashPostAsync
     *
     * Calculate Document Hash.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiHashPostAsync($files = null, $document_password = null, $input_type = null, $output_type = null, $alg = null)
    {
        return $this->pdfWebapiHashPostAsyncWithHttpInfo($files, $document_password, $input_type, $output_type, $alg)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiHashPostAsyncWithHttpInfo
     *
     * Calculate Document Hash.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiHashPostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $alg = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiHashPostRequest($files, $document_password, $input_type, $output_type, $alg);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiHashPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\HashAlgorithm $alg The hashing algorithm to use. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiHashPostRequest($files = null, $document_password = null, $input_type = null, $output_type = null, $alg = null)
    {

        $resourcePath = '/pdf/webapi/hash';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($alg !== null) {
            $queryParams['alg'] = ObjectSerializer::toQueryValue($alg, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiLockPost
     *
     * Lock document.
     *
     * @param  string $password password (optional)
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiLockPost($password = null, $files = null)
    {
        list($response) = $this->pdfWebapiLockPostWithHttpInfo($password, $files);
        return $response;
    }

    /**
     * Operation pdfWebapiLockPostWithHttpInfo
     *
     * Lock document.
     *
     * @param  string $password (optional)
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiLockPostWithHttpInfo($password = null, $files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiLockPostRequest($password, $files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiLockPostAsync
     *
     * Lock document.
     *
     * @param  string $password (optional)
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiLockPostAsync($password = null, $files = null)
    {
        return $this->pdfWebapiLockPostAsyncWithHttpInfo($password, $files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiLockPostAsyncWithHttpInfo
     *
     * Lock document.
     *
     * @param  string $password (optional)
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiLockPostAsyncWithHttpInfo($password = null, $files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiLockPostRequest($password, $files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiLockPost'
     *
     * @param  string $password (optional)
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiLockPostRequest($password = null, $files = null)
    {

        $resourcePath = '/pdf/webapi/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($passw !== null) {
            $queryParams['passw'] = ObjectSerializer::toQueryValue($passw, null);
        }


        // form params
        if ($password !== null) {
            $formParams['password'] = ObjectSerializer::toFormValue($password);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiMergePost
     *
     * Merge Documents.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiMergePost($files = null, $document_password = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        list($response) = $this->pdfWebapiMergePostWithHttpInfo($files, $document_password, $input_type, $output_type, $merge_type, $horizontal, $vertical, $page_size, $dc_is_landscape);
        return $response;
    }

    /**
     * Operation pdfWebapiMergePostWithHttpInfo
     *
     * Merge Documents.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiMergePostWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMergePostRequest($files, $document_password, $input_type, $output_type, $merge_type, $horizontal, $vertical, $page_size, $dc_is_landscape);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiMergePostAsync
     *
     * Merge Documents.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMergePostAsync($files = null, $document_password = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        return $this->pdfWebapiMergePostAsyncWithHttpInfo($files, $document_password, $input_type, $output_type, $merge_type, $horizontal, $vertical, $page_size, $dc_is_landscape)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiMergePostAsyncWithHttpInfo
     *
     * Merge Documents.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMergePostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMergePostRequest($files, $document_password, $input_type, $output_type, $merge_type, $horizontal, $vertical, $page_size, $dc_is_landscape);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiMergePost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output file. (optional)
     * @param  \Swagger\Client\Model\MergeImageType $merge_type Type of merger operation. (optional)
     * @param  int $horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param  int $vertical The number of images to merge vertically, if applicable. (optional)
     * @param  \Swagger\Client\Model\PageSize $page_size The page size for the output file, if applicable. (optional)
     * @param  bool $dc_is_landscape Indicates whether the output file should be in landscape orientation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiMergePostRequest($files = null, $document_password = null, $input_type = null, $output_type = null, $merge_type = null, $horizontal = null, $vertical = null, $page_size = null, $dc_is_landscape = null)
    {

        $resourcePath = '/pdf/webapi/merge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($merge_type !== null) {
            $queryParams['mergeType'] = ObjectSerializer::toQueryValue($merge_type, null);
        }
        // query params
        if ($horizontal !== null) {
            $queryParams['horizontal'] = ObjectSerializer::toQueryValue($horizontal, 'int32');
        }
        // query params
        if ($vertical !== null) {
            $queryParams['vertical'] = ObjectSerializer::toQueryValue($vertical, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, null);
        }
        // query params
        if ($dc_is_landscape !== null) {
            $queryParams['dc_isLandscape'] = ObjectSerializer::toQueryValue($dc_is_landscape, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiMetadataPost
     *
     * Read and Change Document Metadata.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiMetadataPost($files = null, $document_password = null, $operation = null, $folder = null, $name = null)
    {
        list($response) = $this->pdfWebapiMetadataPostWithHttpInfo($files, $document_password, $operation, $folder, $name);
        return $response;
    }

    /**
     * Operation pdfWebapiMetadataPostWithHttpInfo
     *
     * Read and Change Document Metadata.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiMetadataPostWithHttpInfo($files = null, $document_password = null, $operation = null, $folder = null, $name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMetadataPostRequest($files, $document_password, $operation, $folder, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiMetadataPostAsync
     *
     * Read and Change Document Metadata.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMetadataPostAsync($files = null, $document_password = null, $operation = null, $folder = null, $name = null)
    {
        return $this->pdfWebapiMetadataPostAsyncWithHttpInfo($files, $document_password, $operation, $folder, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiMetadataPostAsyncWithHttpInfo
     *
     * Read and Change Document Metadata.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiMetadataPostAsyncWithHttpInfo($files = null, $document_password = null, $operation = null, $folder = null, $name = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiMetadataPostRequest($files, $document_password, $operation, $folder, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiMetadataPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\MetadataOperation $operation The operation to perform on the metadata. (optional)
     * @param  string $folder The folder where the files are located. (optional)
     * @param  string $name The name of the file to perform the operation on. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiMetadataPostRequest($files = null, $document_password = null, $operation = null, $folder = null, $name = null)
    {

        $resourcePath = '/pdf/webapi/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($operation !== null) {
            $queryParams['operation'] = ObjectSerializer::toQueryValue($operation, null);
        }
        // query params
        if ($folder !== null) {
            $queryParams['folder'] = ObjectSerializer::toQueryValue($folder, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiOrganizePost
     *
     * Organize Document Pages.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiOrganizePost($files = null, $document_password = null, $input_type = null, $remove = null, $move = null)
    {
        list($response) = $this->pdfWebapiOrganizePostWithHttpInfo($files, $document_password, $input_type, $remove, $move);
        return $response;
    }

    /**
     * Operation pdfWebapiOrganizePostWithHttpInfo
     *
     * Organize Document Pages.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiOrganizePostWithHttpInfo($files = null, $document_password = null, $input_type = null, $remove = null, $move = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiOrganizePostRequest($files, $document_password, $input_type, $remove, $move);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiOrganizePostAsync
     *
     * Organize Document Pages.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiOrganizePostAsync($files = null, $document_password = null, $input_type = null, $remove = null, $move = null)
    {
        return $this->pdfWebapiOrganizePostAsyncWithHttpInfo($files, $document_password, $input_type, $remove, $move)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiOrganizePostAsyncWithHttpInfo
     *
     * Organize Document Pages.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiOrganizePostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null, $remove = null, $move = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiOrganizePostRequest($files, $document_password, $input_type, $remove, $move);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiOrganizePost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $remove The pages to remove from the document. (optional)
     * @param  string $move The pages to move within the document. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiOrganizePostRequest($files = null, $document_password = null, $input_type = null, $remove = null, $move = null)
    {

        $resourcePath = '/pdf/webapi/organize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($remove !== null) {
            $queryParams['remove'] = ObjectSerializer::toQueryValue($remove, null);
        }
        // query params
        if ($move !== null) {
            $queryParams['move'] = ObjectSerializer::toQueryValue($move, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiParsePost
     *
     * Parse Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiParsePost($files = null, $document_password = null)
    {
        list($response) = $this->pdfWebapiParsePostWithHttpInfo($files, $document_password);
        return $response;
    }

    /**
     * Operation pdfWebapiParsePostWithHttpInfo
     *
     * Parse Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiParsePostWithHttpInfo($files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiParsePostRequest($files, $document_password);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiParsePostAsync
     *
     * Parse Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiParsePostAsync($files = null, $document_password = null)
    {
        return $this->pdfWebapiParsePostAsyncWithHttpInfo($files, $document_password)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiParsePostAsyncWithHttpInfo
     *
     * Parse Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiParsePostAsyncWithHttpInfo($files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiParsePostRequest($files, $document_password);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiParsePost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiParsePostRequest($files = null, $document_password = null)
    {

        $resourcePath = '/pdf/webapi/parse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }


        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRedactPost
     *
     * Redact Document Text.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRedactPost($files = null, $document_password = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        list($response) = $this->pdfWebapiRedactPostWithHttpInfo($files, $document_password, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata);
        return $response;
    }

    /**
     * Operation pdfWebapiRedactPostWithHttpInfo
     *
     * Redact Document Text.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRedactPostWithHttpInfo($files = null, $document_password = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRedactPostRequest($files, $document_password, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRedactPostAsync
     *
     * Redact Document Text.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRedactPostAsync($files = null, $document_password = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        return $this->pdfWebapiRedactPostAsyncWithHttpInfo($files, $document_password, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRedactPostAsyncWithHttpInfo
     *
     * Redact Document Text.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRedactPostAsyncWithHttpInfo($files = null, $document_password = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRedactPostRequest($files, $document_password, $search_query, $replace_text, $case_sensitive, $text, $comments, $metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRedactPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $search_query The text to search for and redact. (optional)
     * @param  string $replace_text The text to replace the found text with. (optional)
     * @param  bool $case_sensitive Indicates whether the search should be case-sensitive. (optional)
     * @param  bool $text Indicates whether text should be redacted. (optional)
     * @param  bool $comments Indicates whether comments should be redacted. (optional)
     * @param  bool $metadata Indicates whether metadata should be redacted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRedactPostRequest($files = null, $document_password = null, $search_query = null, $replace_text = null, $case_sensitive = null, $text = null, $comments = null, $metadata = null)
    {

        $resourcePath = '/pdf/webapi/redact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_query !== null) {
            $queryParams['searchQuery'] = ObjectSerializer::toQueryValue($search_query, null);
        }
        // query params
        if ($replace_text !== null) {
            $queryParams['replaceText'] = ObjectSerializer::toQueryValue($replace_text, null);
        }
        // query params
        if ($case_sensitive !== null) {
            $queryParams['caseSensitive'] = ObjectSerializer::toQueryValue($case_sensitive, null);
        }
        // query params
        if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text, null);
        }
        // query params
        if ($comments !== null) {
            $queryParams['comments'] = ObjectSerializer::toQueryValue($comments, null);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = ObjectSerializer::toQueryValue($metadata, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemoveIdPost
     *
     * Remove stored files.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemoveIdPost($id)
    {
        list($response) = $this->pdfWebapiRemoveIdPostWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation pdfWebapiRemoveIdPostWithHttpInfo
     *
     * Remove stored files.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemoveIdPostWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveIdPostRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemoveIdPostAsync
     *
     * Remove stored files.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveIdPostAsync($id)
    {
        return $this->pdfWebapiRemoveIdPostAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemoveIdPostAsyncWithHttpInfo
     *
     * Remove stored files.
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveIdPostAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveIdPostRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemoveIdPost'
     *
     * @param  string $id The ID of the processing to remove. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemoveIdPostRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiRemoveIdPost'
            );
        }

        $resourcePath = '/pdf/webapi/remove/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemovePost
     *
     * Remove Document Annotations.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemovePost($files = null, $document_password = null)
    {
        list($response) = $this->pdfWebapiRemovePostWithHttpInfo($files, $document_password);
        return $response;
    }

    /**
     * Operation pdfWebapiRemovePostWithHttpInfo
     *
     * Remove Document Annotations.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemovePostWithHttpInfo($files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovePostRequest($files, $document_password);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemovePostAsync
     *
     * Remove Document Annotations.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovePostAsync($files = null, $document_password = null)
    {
        return $this->pdfWebapiRemovePostAsyncWithHttpInfo($files, $document_password)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemovePostAsyncWithHttpInfo
     *
     * Remove Document Annotations.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovePostAsyncWithHttpInfo($files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovePostRequest($files, $document_password);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemovePost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemovePostRequest($files = null, $document_password = null)
    {

        $resourcePath = '/pdf/webapi/remove';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPost
     *
     * Remove Document Watermark.
     *
     * @param  string $watermark_text watermark_text (optional)
     * @param  int $top top (optional)
     * @param  int $left left (optional)
     * @param  int $bottom bottom (optional)
     * @param  int $right right (optional)
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemoveWatermarkPost($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $document_password = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        list($response) = $this->pdfWebapiRemoveWatermarkPostWithHttpInfo($watermark_text, $top, $left, $bottom, $right, $files, $document_password, $is_all_pages, $watermark_type, $remove_range);
        return $response;
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPostWithHttpInfo
     *
     * Remove Document Watermark.
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemoveWatermarkPostWithHttpInfo($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $document_password = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveWatermarkPostRequest($watermark_text, $top, $left, $bottom, $right, $files, $document_password, $is_all_pages, $watermark_type, $remove_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPostAsync
     *
     * Remove Document Watermark.
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveWatermarkPostAsync($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $document_password = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        return $this->pdfWebapiRemoveWatermarkPostAsyncWithHttpInfo($watermark_text, $top, $left, $bottom, $right, $files, $document_password, $is_all_pages, $watermark_type, $remove_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemoveWatermarkPostAsyncWithHttpInfo
     *
     * Remove Document Watermark.
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemoveWatermarkPostAsyncWithHttpInfo($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $document_password = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemoveWatermarkPostRequest($watermark_text, $top, $left, $bottom, $right, $files, $document_password, $is_all_pages, $watermark_type, $remove_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemoveWatermarkPost'
     *
     * @param  string $watermark_text (optional)
     * @param  int $top (optional)
     * @param  int $left (optional)
     * @param  int $bottom (optional)
     * @param  int $right (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  bool $is_all_pages Indicates whether the watermark should be removed from all pages. (optional)
     * @param  \Swagger\Client\Model\WatermarkType $watermark_type The type of watermark to remove. (optional)
     * @param  string $remove_range The range of pages to remove the watermark from. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemoveWatermarkPostRequest($watermark_text = null, $top = null, $left = null, $bottom = null, $right = null, $files = null, $document_password = null, $is_all_pages = null, $watermark_type = null, $remove_range = null)
    {

        $resourcePath = '/pdf/webapi/remove-watermark';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($is_all_pages !== null) {
            $queryParams['isAllPages'] = ObjectSerializer::toQueryValue($is_all_pages, null);
        }
        // query params
        if ($watermark_type !== null) {
            $queryParams['watermarkType'] = ObjectSerializer::toQueryValue($watermark_type, null);
        }
        // query params
        if ($remove_range !== null) {
            $queryParams['removeRange'] = ObjectSerializer::toQueryValue($remove_range, null);
        }


        // form params
        if ($watermark_text !== null) {
            $formParams['watermarkText'] = ObjectSerializer::toFormValue($watermark_text);
        }
        // form params
        if ($top !== null) {
            $formParams['top'] = ObjectSerializer::toFormValue($top);
        }
        // form params
        if ($left !== null) {
            $formParams['left'] = ObjectSerializer::toFormValue($left);
        }
        // form params
        if ($bottom !== null) {
            $formParams['bottom'] = ObjectSerializer::toFormValue($bottom);
        }
        // form params
        if ($right !== null) {
            $formParams['right'] = ObjectSerializer::toFormValue($right);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRemovepagesPost
     *
     * Remove Pages from Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRemovepagesPost($files = null, $document_password = null, $remove_range = null)
    {
        list($response) = $this->pdfWebapiRemovepagesPostWithHttpInfo($files, $document_password, $remove_range);
        return $response;
    }

    /**
     * Operation pdfWebapiRemovepagesPostWithHttpInfo
     *
     * Remove Pages from Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRemovepagesPostWithHttpInfo($files = null, $document_password = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovepagesPostRequest($files, $document_password, $remove_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRemovepagesPostAsync
     *
     * Remove Pages from Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovepagesPostAsync($files = null, $document_password = null, $remove_range = null)
    {
        return $this->pdfWebapiRemovepagesPostAsyncWithHttpInfo($files, $document_password, $remove_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRemovepagesPostAsyncWithHttpInfo
     *
     * Remove Pages from Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRemovepagesPostAsyncWithHttpInfo($files = null, $document_password = null, $remove_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRemovepagesPostRequest($files, $document_password, $remove_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRemovepagesPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $remove_range The range of pages to remove from the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRemovepagesPostRequest($files = null, $document_password = null, $remove_range = null)
    {

        $resourcePath = '/pdf/webapi/removepages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($remove_range !== null) {
            $queryParams['removeRange'] = ObjectSerializer::toQueryValue($remove_range, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);


        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }


        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRepairPost
     *
     * Repair Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRepairPost($files = null, $document_password = null)
    {
        list($response) = $this->pdfWebapiRepairPostWithHttpInfo($files, $document_password);
        return $response;
    }

    /**
     * Operation pdfWebapiRepairPostWithHttpInfo
     *
     * Repair Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRepairPostWithHttpInfo($files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRepairPostRequest($files, $document_password);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRepairPostAsync
     *
     * Repair Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRepairPostAsync($files = null, $document_password = null)
    {
        return $this->pdfWebapiRepairPostAsyncWithHttpInfo($files, $document_password)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRepairPostAsyncWithHttpInfo
     *
     * Repair Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRepairPostAsyncWithHttpInfo($files = null, $document_password = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRepairPostRequest($files, $document_password);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRepairPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRepairPostRequest($files = null, $document_password = null)
    {

        $resourcePath = '/pdf/webapi/repair';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiResizePost
     *
     * Resize Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiResizePost($files = null, $document_password = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        list($response) = $this->pdfWebapiResizePostWithHttpInfo($files, $document_password, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size);
        return $response;
    }

    /**
     * Operation pdfWebapiResizePostWithHttpInfo
     *
     * Resize Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiResizePostWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiResizePostRequest($files, $document_password, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiResizePostAsync
     *
     * Resize Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiResizePostAsync($files = null, $document_password = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        return $this->pdfWebapiResizePostAsyncWithHttpInfo($files, $document_password, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiResizePostAsyncWithHttpInfo
     *
     * Resize Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiResizePostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiResizePostRequest($files, $document_password, $input_type, $output_type, $resize_type, $preset_type, $preset_size, $width, $height, $percentage, $use_proportions, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiResizePost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\ResizeType $resize_type The type of resizing to apply. (optional)
     * @param  \Swagger\Client\Model\ResizePresetType $preset_type The type of preset size to use for resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePresetSize $preset_size The preset size to use for resizing. (optional)
     * @param  int $width The desired width of the resized files. (optional)
     * @param  int $height The desired height of the resized files. (optional)
     * @param  int $percentage The percentage to resize the files by. (optional)
     * @param  bool $use_proportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param  \Swagger\Client\Model\ResizePageSize $page_size The page size to use for the resized files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiResizePostRequest($files = null, $document_password = null, $input_type = null, $output_type = null, $resize_type = null, $preset_type = null, $preset_size = null, $width = null, $height = null, $percentage = null, $use_proportions = null, $page_size = null)
    {

        $resourcePath = '/pdf/webapi/resize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($resize_type !== null) {
            $queryParams['resizeType'] = ObjectSerializer::toQueryValue($resize_type, null);
        }
        // query params
        if ($preset_type !== null) {
            $queryParams['presetType'] = ObjectSerializer::toQueryValue($preset_type, null);
        }
        // query params
        if ($preset_size !== null) {
            $queryParams['presetSize'] = ObjectSerializer::toQueryValue($preset_size, null);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width, 'int32');
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height, 'int32');
        }
        // query params
        if ($percentage !== null) {
            $queryParams['percentage'] = ObjectSerializer::toQueryValue($percentage, 'int32');
        }
        // query params
        if ($use_proportions !== null) {
            $queryParams['useProportions'] = ObjectSerializer::toQueryValue($use_proportions, null);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiRotatePost
     *
     * Rotate Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiRotatePost($files = null, $document_password = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        list($response) = $this->pdfWebapiRotatePostWithHttpInfo($files, $document_password, $angle, $rotate_type, $page_num);
        return $response;
    }

    /**
     * Operation pdfWebapiRotatePostWithHttpInfo
     *
     * Rotate Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiRotatePostWithHttpInfo($files = null, $document_password = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRotatePostRequest($files, $document_password, $angle, $rotate_type, $page_num);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiRotatePostAsync
     *
     * Rotate Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRotatePostAsync($files = null, $document_password = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        return $this->pdfWebapiRotatePostAsyncWithHttpInfo($files, $document_password, $angle, $rotate_type, $page_num)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiRotatePostAsyncWithHttpInfo
     *
     * Rotate Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiRotatePostAsyncWithHttpInfo($files = null, $document_password = null, $angle = null, $rotate_type = null, $page_num = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiRotatePostRequest($files, $document_password, $angle, $rotate_type, $page_num);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiRotatePost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\RotateAngle $angle The angle by which to rotate the files. (optional)
     * @param  \Swagger\Client\Model\RotateType $rotate_type The type of rotation to perform. (optional)
     * @param  string $page_num The page number to rotate, if applicable. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiRotatePostRequest($files = null, $document_password = null, $angle = null, $rotate_type = null, $page_num = null)
    {

        $resourcePath = '/pdf/webapi/rotate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($angle !== null) {
            $queryParams['angle'] = ObjectSerializer::toQueryValue($angle, null);
        }
        // query params
        if ($rotate_type !== null) {
            $queryParams['rotateType'] = ObjectSerializer::toQueryValue($rotate_type, null);
        }
        // query params
        if ($page_num !== null) {
            $queryParams['pageNum'] = ObjectSerializer::toQueryValue($page_num, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSearchPost
     *
     * Search Document Text.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSearchPost($files = null, $document_password = null, $query = null)
    {
        list($response) = $this->pdfWebapiSearchPostWithHttpInfo($files, $document_password, $query);
        return $response;
    }

    /**
     * Operation pdfWebapiSearchPostWithHttpInfo
     *
     * Search Document Text.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSearchPostWithHttpInfo($files = null, $document_password = null, $query = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchPostRequest($files, $document_password, $query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSearchPostAsync
     *
     * Search Document Text.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchPostAsync($files = null, $document_password = null, $query = null)
    {
        return $this->pdfWebapiSearchPostAsyncWithHttpInfo($files, $document_password, $query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSearchPostAsyncWithHttpInfo
     *
     * Search Document Text.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchPostAsyncWithHttpInfo($files = null, $document_password = null, $query = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchPostRequest($files, $document_password, $query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSearchPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $query The text to search for within the files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSearchPostRequest($files = null, $document_password = null, $query = null)
    {

        $resourcePath = '/pdf/webapi/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSearchablePost
     *
     * Make Scanned PDF Searchable.
     *
     * @param  string[] $files files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSearchablePost($files = null, $lang = null)
    {
        list($response) = $this->pdfWebapiSearchablePostWithHttpInfo($files, $lang);
        return $response;
    }

    /**
     * Operation pdfWebapiSearchablePostWithHttpInfo
     *
     * Make Scanned PDF Searchable.
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSearchablePostWithHttpInfo($files = null, $lang = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchablePostRequest($files, $lang);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSearchablePostAsync
     *
     * Make Scanned PDF Searchable.
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchablePostAsync($files = null, $lang = null)
    {
        return $this->pdfWebapiSearchablePostAsyncWithHttpInfo($files, $lang)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSearchablePostAsyncWithHttpInfo
     *
     * Make Scanned PDF Searchable.
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSearchablePostAsyncWithHttpInfo($files = null, $lang = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSearchablePostRequest($files, $lang);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSearchablePost'
     *
     * @param  string[] $files (optional)
     * @param  string $lang The language of the files to be converted. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSearchablePostRequest($files = null, $lang = null)
    {

        $resourcePath = '/pdf/webapi/searchable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSignaturePost
     *
     * Add Signature to Document.
     *
     * @param  string $image image (optional)
     * @param  string $text text (optional)
     * @param  string $text_color text_color (optional)
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSignaturePost($image = null, $text = null, $text_color = null, $files = null, $document_password = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        list($response) = $this->pdfWebapiSignaturePostWithHttpInfo($image, $text, $text_color, $files, $document_password, $input_type, $output_type, $signature_type);
        return $response;
    }

    /**
     * Operation pdfWebapiSignaturePostWithHttpInfo
     *
     * Add Signature to Document.
     *
     * @param  string $image (optional)
     * @param  string $text (optional)
     * @param  string $text_color (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSignaturePostWithHttpInfo($image = null, $text = null, $text_color = null, $files = null, $document_password = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSignaturePostRequest($image, $text, $text_color, $files, $document_password, $input_type, $output_type, $signature_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSignaturePostAsync
     *
     * Add Signature to Document.
     *
     * @param  string $image (optional)
     * @param  string $text (optional)
     * @param  string $text_color (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSignaturePostAsync($image = null, $text = null, $text_color = null, $files = null, $document_password = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        return $this->pdfWebapiSignaturePostAsyncWithHttpInfo($image, $text, $text_color, $files, $document_password, $input_type, $output_type, $signature_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSignaturePostAsyncWithHttpInfo
     *
     * Add Signature to Document.
     *
     * @param  string $image (optional)
     * @param  string $text (optional)
     * @param  string $text_color (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSignaturePostAsyncWithHttpInfo($image = null, $text = null, $text_color = null, $files = null, $document_password = null, $input_type = null, $output_type = null, $signature_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSignaturePostRequest($image, $text, $text_color, $files, $document_password, $input_type, $output_type, $signature_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSignaturePost'
     *
     * @param  string $image (optional)
     * @param  string $text (optional)
     * @param  string $text_color (optional)
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  \Swagger\Client\Model\SignatureType $signature_type The type of signature to add. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSignaturePostRequest($image = null, $text = null, $text_color = null, $files = null, $document_password = null, $input_type = null, $output_type = null, $signature_type = null)
    {

        $resourcePath = '/pdf/webapi/signature';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($signature_type !== null) {
            $queryParams['signatureType'] = ObjectSerializer::toQueryValue($signature_type, null);
        }


        // form params
        if ($image !== null) {
            $formParams['image'] = ObjectSerializer::toFormValue($image);
        }
        // form params
        if ($text !== null) {
            $formParams['text'] = ObjectSerializer::toFormValue($text);
        }
        // form params
        if ($text_color !== null) {
            $formParams['textColor'] = ObjectSerializer::toFormValue($text_color);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSplitdocPost
     *
     * Split Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pairs Optional page rage for the splitting operation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSplitdocPost($files = null, $document_password = null, $input_type = null, $split_type = null, $pairs = null)
    {
        list($response) = $this->pdfWebapiSplitdocPostWithHttpInfo($files, $document_password, $input_type, $split_type, $pairs);
        return $response;
    }

    /**
     * Operation pdfWebapiSplitdocPostWithHttpInfo
     *
     * Split Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pairs Optional page rage for the splitting operation. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSplitdocPostWithHttpInfo($files = null, $document_password = null, $input_type = null, $split_type = null, $pairs = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitdocPostRequest($files, $document_password, $input_type, $split_type, $pairs);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSplitdocPostAsync
     *
     * Split Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pairs Optional page rage for the splitting operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitdocPostAsync($files = null, $document_password = null, $input_type = null, $split_type = null, $pairs = null)
    {
        return $this->pdfWebapiSplitdocPostAsyncWithHttpInfo($files, $document_password, $input_type, $split_type, $pairs)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSplitdocPostAsyncWithHttpInfo
     *
     * Split Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pairs Optional page rage for the splitting operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitdocPostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null, $split_type = null, $pairs = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitdocPostRequest($files, $document_password, $input_type, $split_type, $pairs);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSplitdocPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  \Swagger\Client\Model\SplitDocType $split_type The type of splitting to be performed. (optional)
     * @param  string $pairs Optional page rage for the splitting operation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSplitdocPostRequest($files = null, $document_password = null, $input_type = null, $split_type = null, $pairs = null)
    {

        $resourcePath = '/pdf/webapi/splitdoc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($split_type !== null) {
            $queryParams['splitType'] = ObjectSerializer::toQueryValue($split_type, null);
        }
        // query params
        if ($pairs !== null) {
            $queryParams['pairs'] = ObjectSerializer::toQueryValue($pairs, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiSplitimagePost
     *
     * Split Image.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiSplitimagePost($files = null, $document_password = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        list($response) = $this->pdfWebapiSplitimagePostWithHttpInfo($files, $document_password, $split_type, $vertical, $horizontal, $output_type);
        return $response;
    }

    /**
     * Operation pdfWebapiSplitimagePostWithHttpInfo
     *
     * Split Image.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiSplitimagePostWithHttpInfo($files = null, $document_password = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitimagePostRequest($files, $document_password, $split_type, $vertical, $horizontal, $output_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiSplitimagePostAsync
     *
     * Split Image.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitimagePostAsync($files = null, $document_password = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        return $this->pdfWebapiSplitimagePostAsyncWithHttpInfo($files, $document_password, $split_type, $vertical, $horizontal, $output_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiSplitimagePostAsyncWithHttpInfo
     *
     * Split Image.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiSplitimagePostAsyncWithHttpInfo($files = null, $document_password = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiSplitimagePostRequest($files, $document_password, $split_type, $vertical, $horizontal, $output_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiSplitimagePost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  \Swagger\Client\Model\SplitImageType $split_type The type of splitting to be performed. (optional)
     * @param  int $vertical The number of vertical splits to create. (optional)
     * @param  int $horizontal The number of horizontal splits to create. (optional)
     * @param  string $output_type The desired output format for the split images. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiSplitimagePostRequest($files = null, $document_password = null, $split_type = null, $vertical = null, $horizontal = null, $output_type = null)
    {

        $resourcePath = '/pdf/webapi/splitimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($split_type !== null) {
            $queryParams['splitType'] = ObjectSerializer::toQueryValue($split_type, null);
        }
        // query params
        if ($vertical !== null) {
            $queryParams['vertical'] = ObjectSerializer::toQueryValue($vertical, 'int32');
        }
        // query params
        if ($horizontal !== null) {
            $queryParams['horizontal'] = ObjectSerializer::toQueryValue($horizontal, 'int32');
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiStatusIdPost
     *
     * Processing status.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiStatusIdPost($id)
    {
        list($response) = $this->pdfWebapiStatusIdPostWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation pdfWebapiStatusIdPostWithHttpInfo
     *
     * Processing status.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiStatusIdPostWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiStatusIdPostRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiStatusIdPostAsync
     *
     * Processing status.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiStatusIdPostAsync($id)
    {
        return $this->pdfWebapiStatusIdPostAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiStatusIdPostAsyncWithHttpInfo
     *
     * Processing status.
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiStatusIdPostAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiStatusIdPostRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiStatusIdPost'
     *
     * @param  string $id The ID of the processing to check the status of. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiStatusIdPostRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pdfWebapiStatusIdPost'
            );
        }

        $resourcePath = '/pdf/webapi/status/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiUnlockPost
     *
     * Unlock Document.
     *
     * @param  string $password password (optional)
     * @param  string[] $files files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiUnlockPost($password = null, $files = null)
    {
        list($response) = $this->pdfWebapiUnlockPostWithHttpInfo($password, $files);
        return $response;
    }

    /**
     * Operation pdfWebapiUnlockPostWithHttpInfo
     *
     * Unlock Document.
     *
     * @param  string $password (optional)
     * @param  string[] $files (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiUnlockPostWithHttpInfo($password = null, $files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiUnlockPostRequest($password, $files);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiUnlockPostAsync
     *
     * Unlock Document.
     *
     * @param  string $password (optional)
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiUnlockPostAsync($password = null, $files = null)
    {
        return $this->pdfWebapiUnlockPostAsyncWithHttpInfo($password, $files)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiUnlockPostAsyncWithHttpInfo
     *
     * Unlock Document.
     *
     * @param  string $password (optional)
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiUnlockPostAsyncWithHttpInfo($password = null, $files = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiUnlockPostRequest($password, $files);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiUnlockPost'
     *
     * @param  string $password (optional)
     * @param  string[] $files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiUnlockPostRequest($password = null, $files = null)
    {

        $resourcePath = '/pdf/webapi/unlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($passw !== null) {
            $queryParams['passw'] = ObjectSerializer::toQueryValue($passw, null);
        }


        // form params
        if ($password !== null) {
            $formParams['password'] = ObjectSerializer::toFormValue($password);
        }
        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiVerifyEsignPost
     *
     * Verify Document Certificate.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiVerifyEsignPost($files = null, $document_password = null, $input_type = null)
    {
        list($response) = $this->pdfWebapiVerifyEsignPostWithHttpInfo($files, $document_password, $input_type);
        return $response;
    }

    /**
     * Operation pdfWebapiVerifyEsignPostWithHttpInfo
     *
     * Verify Document Certificate.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiVerifyEsignPostWithHttpInfo($files = null, $document_password = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiVerifyEsignPostRequest($files, $document_password, $input_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiVerifyEsignPostAsync
     *
     * Verify Document Certificate.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiVerifyEsignPostAsync($files = null, $document_password = null, $input_type = null)
    {
        return $this->pdfWebapiVerifyEsignPostAsyncWithHttpInfo($files, $document_password, $input_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiVerifyEsignPostAsyncWithHttpInfo
     *
     * Verify Document Certificate.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiVerifyEsignPostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiVerifyEsignPostRequest($files, $document_password, $input_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiVerifyEsignPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiVerifyEsignPostRequest($files = null, $document_password = null, $input_type = null)
    {

        $resourcePath = '/pdf/webapi/verify_esign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );



        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        $request = new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );

        return  $request;
    }

    /**
     * Operation pdfWebapiWatermarkPost
     *
     * Add Watermark to Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiWatermarkPost($files = null, $document_password = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {
        list($response) = $this->pdfWebapiWatermarkPostWithHttpInfo($files, $document_password, $input_type, $output_type, $is_colored, $is_text, $text, $name, $size, $bold, $italic, $underlined, $color, $is_background, $rotation, $transparency, $layer, $page_from, $page_to);
        return $response;
    }

    /**
     * Operation pdfWebapiWatermarkPostWithHttpInfo
     *
     * Add Watermark to Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiWatermarkPostWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWatermarkPostRequest($files, $document_password, $input_type, $output_type, $is_colored, $is_text, $text, $name, $size, $bold, $italic, $underlined, $color, $is_background, $rotation, $transparency, $layer, $page_from, $page_to);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiWatermarkPostAsync
     *
     * Add Watermark to Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWatermarkPostAsync($files = null, $document_password = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {
        return $this->pdfWebapiWatermarkPostAsyncWithHttpInfo($files, $document_password, $input_type, $output_type, $is_colored, $is_text, $text, $name, $size, $bold, $italic, $underlined, $color, $is_background, $rotation, $transparency, $layer, $page_from, $page_to)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiWatermarkPostAsyncWithHttpInfo
     *
     * Add Watermark to Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWatermarkPostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWatermarkPostRequest($files, $document_password, $input_type, $output_type, $is_colored, $is_text, $text, $name, $size, $bold, $italic, $underlined, $color, $is_background, $rotation, $transparency, $layer, $page_from, $page_to);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiWatermarkPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     * @param  string $output_type The desired format for the output files. (optional)
     * @param  bool $is_colored Indicate is watermark will be in color or grayscale. (optional)
     * @param  bool $is_text Indicates whether the watermark is text. (optional)
     * @param  string $text The text of the watermark. (optional)
     * @param  string $name The name of the font for the text watermark. (optional)
     * @param  int $size The size of the font for the text watermark. (optional)
     * @param  bool $bold Indicates whether the text watermark is bold. (optional)
     * @param  bool $italic Indicates whether the text watermark is italic. (optional)
     * @param  bool $underlined Indicates whether the text watermark is underlined. (optional)
     * @param  string $color The color of the text or image watermark. (optional)
     * @param  bool $is_background Indicates whether the watermark is a background watermark. (optional)
     * @param  int $rotation The rotation angle of the watermark. (optional)
     * @param  float $transparency The transparency of the watermark. (optional)
     * @param  bool $layer Indicates whether the watermark is a layer. (optional)
     * @param  int $page_from The starting page number for the watermark. (optional)
     * @param  int $page_to The ending page number for the watermark. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiWatermarkPostRequest($files = null, $document_password = null, $input_type = null, $output_type = null, $is_colored = null, $is_text = null, $text = null, $name = null, $size = null, $bold = null, $italic = null, $underlined = null, $color = null, $is_background = null, $rotation = null, $transparency = null, $layer = null, $page_from = null, $page_to = null)
    {

        $resourcePath = '/pdf/webapi/watermark';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }
        // query params
        if ($output_type !== null) {
            $queryParams['outputType'] = ObjectSerializer::toQueryValue($output_type, null);
        }
        // query params
        if ($is_colored !== null) {
            $queryParams['isColored'] = ObjectSerializer::toQueryValue($is_colored, null);
        }
        // query params
        if ($is_text !== null) {
            $queryParams['isText'] = ObjectSerializer::toQueryValue($is_text, null);
        }
        // query params
        if ($text !== null) {
            $queryParams['text'] = ObjectSerializer::toQueryValue($text, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size, 'int32');
        }
        // query params
        if ($bold !== null) {
            $queryParams['bold'] = ObjectSerializer::toQueryValue($bold, null);
        }
        // query params
        if ($italic !== null) {
            $queryParams['italic'] = ObjectSerializer::toQueryValue($italic, null);
        }
        // query params
        if ($underlined !== null) {
            $queryParams['underlined'] = ObjectSerializer::toQueryValue($underlined, null);
        }
        // query params
        if ($color !== null) {
            $queryParams['color'] = ObjectSerializer::toQueryValue($color, null);
        }
        // query params
        if ($is_background !== null) {
            $queryParams['isBackground'] = ObjectSerializer::toQueryValue($is_background, null);
        }
        // query params
        if ($rotation !== null) {
            $queryParams['rotation'] = ObjectSerializer::toQueryValue($rotation, 'int32');
        }
        // query params
        if ($transparency !== null) {
            $queryParams['transparency'] = ObjectSerializer::toQueryValue($transparency, 'float');
        }
        // query params
        if ($layer !== null) {
            $queryParams['layer'] = ObjectSerializer::toQueryValue($layer, null);
        }
        // query params
        if ($page_from !== null) {
            $queryParams['pageFrom'] = ObjectSerializer::toQueryValue($page_from, 'int32');
        }
        // query params
        if ($page_to !== null) {
            $queryParams['pageTo'] = ObjectSerializer::toQueryValue($page_to, 'int32');
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;
        $multipart = false;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiWordcounterPost
     *
     * Count Words and Characters in Document.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiWordcounterPost($files = null, $document_password = null, $page_range = null)
    {
        list($response) = $this->pdfWebapiWordcounterPostWithHttpInfo($files, $document_password, $page_range);
        return $response;
    }

    /**
     * Operation pdfWebapiWordcounterPostWithHttpInfo
     *
     * Count Words and Characters in Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiWordcounterPostWithHttpInfo($files = null, $document_password = null, $page_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWordcounterPostRequest($files, $document_password, $page_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiWordcounterPostAsync
     *
     * Count Words and Characters in Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWordcounterPostAsync($files = null, $document_password = null, $page_range = null)
    {
        return $this->pdfWebapiWordcounterPostAsyncWithHttpInfo($files, $document_password, $page_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiWordcounterPostAsyncWithHttpInfo
     *
     * Count Words and Characters in Document.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiWordcounterPostAsyncWithHttpInfo($files = null, $document_password = null, $page_range = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiWordcounterPostRequest($files, $document_password, $page_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiWordcounterPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $page_range The range of pages to count words in. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiWordcounterPostRequest($files = null, $document_password = null, $page_range = null)
    {

        $resourcePath = '/pdf/webapi/wordcounter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page_range !== null) {
            $queryParams['pageRange'] = ObjectSerializer::toQueryValue($page_range, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pdfWebapiXfaconvertPost
     *
     * Convert XFA Format to Another Format.
     *
     * @param  string[] $files files (optional)
     * @param  string $document_password document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileResponse
     */
    public function pdfWebapiXfaconvertPost($files = null, $document_password = null, $input_type = null)
    {
        list($response) = $this->pdfWebapiXfaconvertPostWithHttpInfo($files, $document_password, $input_type);
        return $response;
    }

    /**
     * Operation pdfWebapiXfaconvertPostWithHttpInfo
     *
     * Convert XFA Format to Another Format.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pdfWebapiXfaconvertPostWithHttpInfo($files = null, $document_password = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiXfaconvertPostRequest($files, $document_password, $input_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pdfWebapiXfaconvertPostAsync
     *
     * Convert XFA Format to Another Format.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiXfaconvertPostAsync($files = null, $document_password = null, $input_type = null)
    {
        return $this->pdfWebapiXfaconvertPostAsyncWithHttpInfo($files, $document_password, $input_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pdfWebapiXfaconvertPostAsyncWithHttpInfo
     *
     * Convert XFA Format to Another Format.
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pdfWebapiXfaconvertPostAsyncWithHttpInfo($files = null, $document_password = null, $input_type = null)
    {
        $returnType = '\Swagger\Client\Model\FileResponse';
        $request = $this->pdfWebapiXfaconvertPostRequest($files, $document_password, $input_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pdfWebapiXfaconvertPost'
     *
     * @param  string[] $files (optional)
     * @param  string $document_password (optional)
     * @param  string $input_type The format of the input files. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pdfWebapiXfaconvertPostRequest($files = null, $document_password = null, $input_type = null)
    {

        $resourcePath = '/pdf/webapi/xfaconvert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($input_type !== null) {
            $queryParams['inputType'] = ObjectSerializer::toQueryValue($input_type, null);
        }


        // form params
        if ($files !== null) {
            $formParams['files'] = ObjectSerializer::toFormValue($files);
        }
        // form params
        if ($document_password !== null) {
            $formParams['documentPassword'] = ObjectSerializer::toFormValue($document_password);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['multipart/form-data']
            );
            $multipart = true;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                if (isset($formParams['files']) && is_array($formParams['files'])) {

                    $multipartContents = [];
                    foreach ($formParams['files'] as $file) {
                        if (is_string($file) && file_exists($file) && is_readable($file)) {
                            $contentType = mime_content_type($file);
                            $fileResource = fopen($file, 'r');


                            $multipartContents[] = [
                                'name' => 'files[]',
                                'contents' => new Stream($fileResource),
                                'filename' => basename($file),
                                'headers' => [
                                    'Content-Type' => $contentType,
                                    'Content-Length' => filesize($file),
                                ]
                            ];
                        }
                    }

                    // for HTTP post (form)
                    $httpBody = new MultipartStream($multipartContents);
                }
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);

        if ($multipart) {
            $contentTypeHeader = 'multipart/form-data; boundary=' . $httpBody->getBoundary();
            $headers['Content-Type'] = $contentTypeHeader;
        }

        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}