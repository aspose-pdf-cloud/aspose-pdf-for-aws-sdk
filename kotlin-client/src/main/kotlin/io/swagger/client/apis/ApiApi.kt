/**
 * Aspose.PDF for AWS
 * Aspose.Pdf for AWS provides a comprehensive set of endpoints for various PDF-related tasks, enabling efficient document processing and manipulation. Users can retrieve processing status, download files, manage file locks, parse documents, redact sensitive information, convert between formats, merge files, add watermarks, perform text searches, and much more. With endpoints for tasks like electronic signing, document comparison, and form filling, the API offers extensive functionality to cater to diverse PDF requirements.
 *
 * OpenAPI spec version: v1
 * Contact: sales@aspose.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.CompressType
import io.swagger.client.models.FileResponse
import io.swagger.client.models.HashAlgorithm
import io.swagger.client.models.MergeImageType
import io.swagger.client.models.MetadataOperation
import io.swagger.client.models.PageNumberHorizontalAlign
import io.swagger.client.models.PageNumberVerticalAlign
import io.swagger.client.models.PageSize
import io.swagger.client.models.ResizePageSize
import io.swagger.client.models.ResizePresetSize
import io.swagger.client.models.ResizePresetType
import io.swagger.client.models.ResizeType
import io.swagger.client.models.RotateAngle
import io.swagger.client.models.RotateType
import io.swagger.client.models.SignatureType
import io.swagger.client.models.SplitDocType
import io.swagger.client.models.SplitImageType
import io.swagger.client.models.WatermarkType
import io.swagger.client.models.XmlType

import io.swagger.client.infrastructure.*

class ApiApi(basePath: kotlin.String = "/") : ApiClient(basePath) {

    /**
     * Add Page Numbers to Document.
     * Adds page numbers to your documents based on specified alignment, starting number, and format. The service ensures that page numbers are accurately applied, improving the readability and professionalism of your documents. It supports various formats, including DOC, PPTX, TIFF, DOCX, and PDF, to cater to your specific requirements.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param vAlignment The vertical alignment of the page numbers. (optional)
     * @param hAlignment The horizontal alignment of the page numbers. (optional)
     * @param startingNumber The starting number for the page numbers. (optional)
     * @param sNumber The number of the first page to start numbering from. (optional)
     * @param fNumber The number of the last page to end numbering at. (optional)
     * @param margin The margin around the page numbers. (optional)
     * @param fontSize The font size of the page numbers. (optional)
     * @param format The format of the page numbers. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiAddnumberPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, vAlignment: PageNumberVerticalAlign? = null, hAlignment: PageNumberHorizontalAlign? = null, startingNumber: kotlin.Int? = null, sNumber: kotlin.Int? = null, fNumber: kotlin.Int? = null, margin: kotlin.Int? = null, fontSize: kotlin.Int? = null, format: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (vAlignment != null) {
                put("vAlignment", listOf(vAlignment.toString()))
            }
            if (hAlignment != null) {
                put("hAlignment", listOf(hAlignment.toString()))
            }
            if (startingNumber != null) {
                put("startingNumber", listOf(startingNumber.toString()))
            }
            if (sNumber != null) {
                put("sNumber", listOf(sNumber.toString()))
            }
            if (fNumber != null) {
                put("fNumber", listOf(fNumber.toString()))
            }
            if (margin != null) {
                put("margin", listOf(margin.toString()))
            }
            if (fontSize != null) {
                put("fontSize", listOf(fontSize.toString()))
            }
            if (format != null) {
                put("format", listOf(format.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/addnumber", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Change Fonts in Provided Files.
     * Updates the fonts in your documents according to specified replacements.  Provide the font replacement details as a JSON string and upload your files using multipart/form-data.The service processes these requests asynchronously using Kafka, ensuring efficient handling of your files.
     * @param fontReplacementsJson  (optional)
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiChangeFontsPost(fontReplacementsJson: kotlin.String? = null, files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("fontReplacementsJson" to "$fontReplacementsJson", "files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/change-fonts", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Compare documents text.
     * Compares the text of the provided documents and highlights the differences. Upload the files you want to compare, and the service will analyze them to detect any changes in the text. The result is a new document that clearly marks all text variations, making it easy to review and understand the modifications between the original and updated versions.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiComparisonPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/comparison", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Compress Document.
     * Compresses the provided documents to reduce their file size based on the specified compression level. Upload the documents and choose the desired compression level. The service will reduce the file sizes while maintaining quality, resulting in compressed files that are easier to handle and share, saving storage space and reducing upload and download times.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param compressType The level of compression to use. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiCompressPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, compressType: CompressType? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (compressType != null) {
                put("compressType", listOf(compressType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/compress", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Convert Document to Another Format.
     * Converts documents from one format to another seamlessly. Upload the files you need to convert and specify the target format. The service will handle the conversion process efficiently, ensuring that the resulting document is ready for use in the desired format and compatible with various applications and systems.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @param xmlType The type of XML conversion to perform, if applicable. (optional)
     * @param xmlTag The XML tag to use for conversion, if applicable. (optional)
     * @param fontSise  (optional)
     * @param isToSingle Indicates whether the conversion should result in a single file, if applicable. (optional)
     * @param separator The separator to use when converting, if applicable. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiConvertPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, xmlType: XmlType? = null, xmlTag: kotlin.String? = null, fontSise: kotlin.Int? = null, isToSingle: kotlin.Boolean? = null, separator: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (xmlType != null) {
                put("xmlType", listOf(xmlType.toString()))
            }
            if (xmlTag != null) {
                put("xmlTag", listOf(xmlTag.toString()))
            }
            if (fontSise != null) {
                put("fontSise", listOf(fontSise.toString()))
            }
            if (isToSingle != null) {
                put("isToSingle", listOf(isToSingle.toString()))
            }
            if (separator != null) {
                put("separator", listOf(separator.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/convert", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Convert Web Page to Document.
     * Converts a web page to a document in the specified output format. Provide the URL of the web page and choose the desired format for conversion. The service will create a document that mirrors the content and layout of the original web page, ensuring it is well-formatted and suitable for your needs.
     * @param webPage  (optional)
     * @param documentPassword  (optional)
     * @param outputType The desired format for the output file. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiConvertWebpagePost(webPage: kotlin.String? = null, documentPassword: kotlin.String? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("webPage" to "$webPage", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/convert-webpage", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Crop Document.
     * Crops the provided document to the specified dimensions by removing unwanted areas. Upload the document and specify the dimensions for cropping. The service will adjust the file accordingly, resulting in a precisely cropped document that meets your requirements.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param top The number of pixels to crop from the top. (optional)
     * @param right The number of pixels to crop from the right. (optional)
     * @param bottom The number of pixels to crop from the bottom. (optional)
     * @param left The number of pixels to crop from the left. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiCropPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, top: kotlin.Int? = null, right: kotlin.Int? = null, bottom: kotlin.Int? = null, left: kotlin.Int? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (top != null) {
                put("top", listOf(top.toString()))
            }
            if (right != null) {
                put("right", listOf(right.toString()))
            }
            if (bottom != null) {
                put("bottom", listOf(bottom.toString()))
            }
            if (left != null) {
                put("left", listOf(left.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/crop", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * File download.
     * Downloads processed file.
     * @param id The id of the processing to download. 
     * @param file The name of the file to download. (optional)
     * @return void
     */
    fun pdfWebapiDownloadIdGet(id: kotlin.String, file: kotlin.String? = null): Unit {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (file != null) {
                put("file", listOf(file.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/pdf/webapi/download/{id}".replace("{" + "id" + "}", "$id"), query = localVariableQuery
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Sign Document with Certificate.
     * Applies a digital signature to the provided document using the specified certificate. Upload the document and provide the certificate details, and the service will securely apply the signature, ensuring that the document is authenticated and legally binding.
     * @param passw  (optional)
     * @param initials  (optional)
     * @param invite  (optional)
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiEsignPost(passw: kotlin.String? = null, initials: kotlin.String? = null, invite: kotlin.String? = null, files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("passw" to "$passw", "initials" to "$initials", "invite" to "$invite", "files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/esign", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Extract Tables from Document.
     * Extracts tables from the provided document and converts them into the specified output format. Upload the document containing the tables and choose the format you prefer. The service will extract the tables and deliver them in the selected format, facilitating easier data usage and analysis.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiExtractPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/extract", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Make GIF.
     * Creates a GIF from a collection of images, ensuring smooth transitions and cohesive animation. Upload the images you want to include, and the service will generate a GIF based on your specifications. This service is ideal for animating a series of product shots, creating engaging social media content, or other animation needs.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param keepImagesAsIs Indicates whether the images should be kept as is. (optional)
     * @param resizeToImage The index of the image to resize the other images to. (optional)
     * @param streched  (optional)
     * @param width The width of the GIF. (optional)
     * @param height The height of the GIF. (optional)
     * @param frameTimes The times for each frame in the GIF. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiGifPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, keepImagesAsIs: kotlin.Boolean? = null, resizeToImage: kotlin.Int? = null, streched: kotlin.Boolean? = null, width: kotlin.Int? = null, height: kotlin.Int? = null, frameTimes: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (keepImagesAsIs != null) {
                put("keepImagesAsIs", listOf(keepImagesAsIs.toString()))
            }
            if (resizeToImage != null) {
                put("resizeToImage", listOf(resizeToImage.toString()))
            }
            if (streched != null) {
                put("streched", listOf(streched.toString()))
            }
            if (width != null) {
                put("width", listOf(width.toString()))
            }
            if (height != null) {
                put("height", listOf(height.toString()))
            }
            if (frameTimes != null) {
                put("frameTimes", listOf(frameTimes.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/gif", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Calculate Document Hash.
     * Calculates the hash values for the provided documents using the specified hashing algorithm. Upload the documents and choose the desired algorithm, and the service will generate hash values for each file. This process helps verify that the documents have not been altered or corrupted, ensuring data integrity.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @param alg The hashing algorithm to use. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiHashPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, alg: HashAlgorithm? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (alg != null) {
                put("alg", listOf(alg.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/hash", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Lock document.
     * Locks the provided document with a specified password to restrict access to authorized users only. Upload the file and provide a password, and the service will apply the password protection to secure the document. Optionally, you can include additional files to further enhance the security of the document.
     * @param password  (optional)
     * @param files  (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiLockPost(password: kotlin.String? = null, files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("password" to "$password", "files" to "$files")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/lock", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Merge Documents.
     * Merges multiple documents or images into a single file based on specified preferences for orientation and page size. Upload the files you want to consolidate and define your formatting preferences. This service will combine the files into one, ensuring that the final document or image meets your requirements.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output file. (optional)
     * @param mergeType Type of merger operation. (optional)
     * @param horizontal The number of images to merge horizontally, if applicable. (optional)
     * @param vertical The number of images to merge vertically, if applicable. (optional)
     * @param pageSize The page size for the output file, if applicable. (optional)
     * @param dcIsLandscape Indicates whether the output file should be in landscape orientation. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiMergePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, mergeType: MergeImageType? = null, horizontal: kotlin.Int? = null, vertical: kotlin.Int? = null, pageSize: PageSize? = null, dcIsLandscape: kotlin.Boolean? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (mergeType != null) {
                put("mergeType", listOf(mergeType.toString()))
            }
            if (horizontal != null) {
                put("horizontal", listOf(horizontal.toString()))
            }
            if (vertical != null) {
                put("vertical", listOf(vertical.toString()))
            }
            if (pageSize != null) {
                put("pageSize", listOf(pageSize.toString()))
            }
            if (dcIsLandscape != null) {
                put("dc_isLandscape", listOf(dcIsLandscape.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/merge", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Read and Change Document Metadata.
     * Reads and updates the metadata of the provided documents based on specified operations. Upload the documents and define the metadata changes you need. This service will read the existing metadata, apply the changes, and ensure that your files contain accurate and updated information.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param operation The operation to perform on the metadata. (optional)
     * @param folder The folder where the files are located. (optional)
     * @param name The name of the file to perform the operation on. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiMetadataPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, operation: MetadataOperation? = null, folder: kotlin.String? = null, name: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (operation != null) {
                put("operation", listOf(operation.toString()))
            }
            if (folder != null) {
                put("folder", listOf(folder.toString()))
            }
            if (name != null) {
                put("name", listOf(name.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/metadata", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Organize Document Pages.
     * Reorganizes the pages of the provided document based on your instructions. Upload the document and specify which pages to remove or move, and the service will rearrange the pages accordingly, ensuring that the document is organized as you require.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param remove The pages to remove from the document. (optional)
     * @param move The pages to move within the document. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiOrganizePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, remove: kotlin.String? = null, move: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (remove != null) {
                put("remove", listOf(remove.toString()))
            }
            if (move != null) {
                put("move", listOf(move.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/organize", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Parse Document.
     * Analyses and extracts relevant content from the provided document files. The parsing service organizes the data within your documents to make it accessible and tailored to your specific requirements.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiParsePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/parse", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Redact Document Text.
     * Redacts sensitive information from the provided documents by removing specified text, comments, and metadata. You can specify the text to be redacted and use case-sensitive search to ensure thorough removal. This service helps maintain confidentiality and security by ensuring that sensitive information is completely removed.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param searchQuery The text to search for and redact. (optional)
     * @param replaceText The text to replace the found text with. (optional)
     * @param caseSensitive Indicates whether the search should be case-sensitive. (optional)
     * @param text Indicates whether text should be redacted. (optional)
     * @param comments Indicates whether comments should be redacted. (optional)
     * @param metadata Indicates whether metadata should be redacted. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRedactPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, searchQuery: kotlin.String? = null, replaceText: kotlin.String? = null, caseSensitive: kotlin.Boolean? = null, text: kotlin.Boolean? = null, comments: kotlin.Boolean? = null, metadata: kotlin.Boolean? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (searchQuery != null) {
                put("searchQuery", listOf(searchQuery.toString()))
            }
            if (replaceText != null) {
                put("replaceText", listOf(replaceText.toString()))
            }
            if (caseSensitive != null) {
                put("caseSensitive", listOf(caseSensitive.toString()))
            }
            if (text != null) {
                put("text", listOf(text.toString()))
            }
            if (comments != null) {
                put("comments", listOf(comments.toString()))
            }
            if (metadata != null) {
                put("metadata", listOf(metadata.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/redact", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Remove stored files.
     * Removes processed files from storage.
     * @param id The ID of the processing to remove. 
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRemoveIdPost(id: kotlin.String): FileResponse {
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/remove/{id}".replace("{" + "id" + "}", "$id")
        )
        val response = request<FileResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Remove Document Annotations.
     * Removes all annotations, including comments, highlights, and markup, from the provided documents. By specifying the documents, this service ensures that they are cleaned of any annotations, resulting in a clean and annotation-free file.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRemovePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/remove", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Remove Document Watermark.
     * Removes an unwanted watermark from all pages of the provided document. Submit the document, and this service will efficiently eliminate the watermark, resulting in a clean version of the file without the watermark.
     * @param watermarkText  (optional)
     * @param top  (optional)
     * @param left  (optional)
     * @param bottom  (optional)
     * @param right  (optional)
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param isAllPages Indicates whether the watermark should be removed from all pages. (optional)
     * @param watermarkType The type of watermark to remove. (optional)
     * @param removeRange The range of pages to remove the watermark from. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRemoveWatermarkPost(watermarkText: kotlin.String? = null, top: kotlin.Int? = null, left: kotlin.Int? = null, bottom: kotlin.Int? = null, right: kotlin.Int? = null, files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, isAllPages: kotlin.Boolean? = null, watermarkType: WatermarkType? = null, removeRange: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("watermarkText" to "$watermarkText", "top" to "$top", "left" to "$left", "bottom" to "$bottom", "right" to "$right", "files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (isAllPages != null) {
                put("isAllPages", listOf(isAllPages.toString()))
            }
            if (watermarkType != null) {
                put("watermarkType", listOf(watermarkType.toString()))
            }
            if (removeRange != null) {
                put("removeRange", listOf(removeRange.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/remove-watermark", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Remove Pages from Document.
     * Removes specified pages from the provided document, leaving only the pages you want to keep. Simply provide the document and specify which pages to remove, and the service will process the file accordingly.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param removeRange The range of pages to remove from the files. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRemovepagesPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, removeRange: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (removeRange != null) {
                put("removeRange", listOf(removeRange.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/removepages", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Repair Document.
     * Repairs a corrupted or error-ridden document by identifying and fixing issues. Upload the problematic file, and this service will restore it to a usable state.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRepairPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/repair", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Resize Document.
     * Resizes the document to fit the specified dimensions or preset sizes. Provide the file and specify the desired dimensions, or select from available preset sizes to adjust the document accordingly.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @param resizeType The type of resizing to apply. (optional)
     * @param presetType The type of preset size to use for resizing. (optional)
     * @param presetSize The preset size to use for resizing. (optional)
     * @param width The desired width of the resized files. (optional)
     * @param height The desired height of the resized files. (optional)
     * @param percentage The percentage to resize the files by. (optional)
     * @param useProportions Indicates whether to maintain the aspect ratio when resizing. (optional)
     * @param pageSize The page size to use for the resized files. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiResizePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, resizeType: ResizeType? = null, presetType: ResizePresetType? = null, presetSize: ResizePresetSize? = null, width: kotlin.Int? = null, height: kotlin.Int? = null, percentage: kotlin.Int? = null, useProportions: kotlin.Boolean? = null, pageSize: ResizePageSize? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (resizeType != null) {
                put("resizeType", listOf(resizeType.toString()))
            }
            if (presetType != null) {
                put("presetType", listOf(presetType.toString()))
            }
            if (presetSize != null) {
                put("presetSize", listOf(presetSize.toString()))
            }
            if (width != null) {
                put("width", listOf(width.toString()))
            }
            if (height != null) {
                put("height", listOf(height.toString()))
            }
            if (percentage != null) {
                put("percentage", listOf(percentage.toString()))
            }
            if (useProportions != null) {
                put("useProportions", listOf(useProportions.toString()))
            }
            if (pageSize != null) {
                put("pageSize", listOf(pageSize.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/resize", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Rotate Document.
     * Rotates the document by a specified angle, allowing for adjustment of the document&#x27;s orientation. You can choose the type of rotation and target specific pages to ensure the document is aligned according to your needs.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param angle The angle by which to rotate the files. (optional)
     * @param rotateType The type of rotation to perform. (optional)
     * @param pageNum The page number to rotate, if applicable. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiRotatePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, angle: RotateAngle? = null, rotateType: RotateType? = null, pageNum: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (angle != null) {
                put("angle", listOf(angle.toString()))
            }
            if (rotateType != null) {
                put("rotateType", listOf(rotateType.toString()))
            }
            if (pageNum != null) {
                put("pageNum", listOf(pageNum.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/rotate", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Search Document Text.
     * Searches the provided documents for the specified query and highlights the found text with a yellow background. This service helps you quickly locate and review relevant sections of your documents.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param query The text to search for within the files. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSearchPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, query: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (query != null) {
                put("query", listOf(query.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/search", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Make Scanned PDF Searchable.
     * Converts scanned PDFs into a searchable PDF format by recognizing and indexing text. This service ensures that you can easily search through your documents by making the text searchable in the specified language.
     * @param files  (optional)
     * @param lang The language of the files to be converted. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSearchablePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, lang: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (lang != null) {
                put("lang", listOf(lang.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/searchable", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Add Signature to Document.
     * Adds a signature to the provided documents, allowing for the insertion of both text and image signatures. This service ensures that your documents are properly signed and authenticated according to your specifications.
     * @param image  (optional)
     * @param text  (optional)
     * @param textColor  (optional)
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @param signatureType The type of signature to add. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSignaturePost(image: kotlin.String? = null, text: kotlin.String? = null, textColor: kotlin.String? = null, files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, signatureType: SignatureType? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("image" to "$image", "text" to "$text", "textColor" to "$textColor", "files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (signatureType != null) {
                put("signatureType", listOf(signatureType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/signature", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Split Document.
     * Splits a document into smaller parts based on specified criteria, such as type or page range. This service ensures that each segment meets your exact requirements, simplifying document management and organization.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param splitType The type of splitting to be performed. (optional)
     * @param pairs Optional page rage for the splitting operation. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSplitdocPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, splitType: SplitDocType? = null, pairs: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (splitType != null) {
                put("splitType", listOf(splitType.toString()))
            }
            if (pairs != null) {
                put("pairs", listOf(pairs.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/splitdoc", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Split Image.
     * Splits large images into smaller sections according to the specified parameters, making it easier to handle and process image data.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param splitType The type of splitting to be performed. (optional)
     * @param vertical The number of vertical splits to create. (optional)
     * @param horizontal The number of horizontal splits to create. (optional)
     * @param outputType The desired output format for the split images. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiSplitimagePost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, splitType: SplitImageType? = null, vertical: kotlin.Int? = null, horizontal: kotlin.Int? = null, outputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (splitType != null) {
                put("splitType", listOf(splitType.toString()))
            }
            if (vertical != null) {
                put("vertical", listOf(vertical.toString()))
            }
            if (horizontal != null) {
                put("horizontal", listOf(horizontal.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/splitimage", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Processing status.
     * Retrieves the status of a processing.
     * @param id The ID of the processing to check the status of. 
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiStatusIdPost(id: kotlin.String): FileResponse {
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/status/{id}".replace("{" + "id" + "}", "$id")
        )
        val response = request<FileResponse>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Unlock Document.
     * Attempts to unlock a password-protected document, using any associated files if necessary, to grant access to the content.
     * @param password  (optional)
     * @param files  (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiUnlockPost(password: kotlin.String? = null, files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("password" to "$password", "files" to "$files")
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/unlock", headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Verify Document Certificate.
     * Verifies the electronic signature of the provided document to ensure its authenticity and integrity. This service checks the digital certificates in the document to confirm their validity and trustworthiness.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiVerifyEsignPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/verify_esign", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Add Watermark to Document.
     * Adds a watermark to the provided documents, helping to protect and identify them. This service ensures that the watermark is applied according to your specifications, enhancing the security and ownership of your content.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @param outputType The desired format for the output files. (optional)
     * @param isColored Indicate is watermark will be in color or grayscale. (optional)
     * @param isText Indicates whether the watermark is text. (optional)
     * @param text The text of the watermark. (optional)
     * @param name The name of the font for the text watermark. (optional)
     * @param size The size of the font for the text watermark. (optional)
     * @param bold Indicates whether the text watermark is bold. (optional)
     * @param italic Indicates whether the text watermark is italic. (optional)
     * @param underlined Indicates whether the text watermark is underlined. (optional)
     * @param color The color of the text or image watermark. (optional)
     * @param isBackground Indicates whether the watermark is a background watermark. (optional)
     * @param rotation The rotation angle of the watermark. (optional)
     * @param transparency The transparency of the watermark. (optional)
     * @param layer Indicates whether the watermark is a layer. (optional)
     * @param pageFrom The starting page number for the watermark. (optional)
     * @param pageTo The ending page number for the watermark. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiWatermarkPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null, outputType: kotlin.String? = null, isColored: kotlin.Boolean? = null, isText: kotlin.Boolean? = null, text: kotlin.String? = null, name: kotlin.String? = null, size: kotlin.Int? = null, bold: kotlin.Boolean? = null, italic: kotlin.Boolean? = null, underlined: kotlin.Boolean? = null, color: kotlin.String? = null, isBackground: kotlin.Boolean? = null, rotation: kotlin.Int? = null, transparency: kotlin.Float? = null, layer: kotlin.Boolean? = null, pageFrom: kotlin.Int? = null, pageTo: kotlin.Int? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
            if (outputType != null) {
                put("outputType", listOf(outputType.toString()))
            }
            if (isColored != null) {
                put("isColored", listOf(isColored.toString()))
            }
            if (isText != null) {
                put("isText", listOf(isText.toString()))
            }
            if (text != null) {
                put("text", listOf(text.toString()))
            }
            if (name != null) {
                put("name", listOf(name.toString()))
            }
            if (size != null) {
                put("size", listOf(size.toString()))
            }
            if (bold != null) {
                put("bold", listOf(bold.toString()))
            }
            if (italic != null) {
                put("italic", listOf(italic.toString()))
            }
            if (underlined != null) {
                put("underlined", listOf(underlined.toString()))
            }
            if (color != null) {
                put("color", listOf(color.toString()))
            }
            if (isBackground != null) {
                put("isBackground", listOf(isBackground.toString()))
            }
            if (rotation != null) {
                put("rotation", listOf(rotation.toString()))
            }
            if (transparency != null) {
                put("transparency", listOf(transparency.toString()))
            }
            if (layer != null) {
                put("layer", listOf(layer.toString()))
            }
            if (pageFrom != null) {
                put("pageFrom", listOf(pageFrom.toString()))
            }
            if (pageTo != null) {
                put("pageTo", listOf(pageTo.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/watermark", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Count Words and Characters in Document.
     * Counts the words and characters in the provided documents within the specified page range. This service helps you accurately determine the length and content density of your documents, ensuring compliance with any required specifications or limits.
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param pageRange The range of pages to count words in. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiWordcounterPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, pageRange: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (pageRange != null) {
                put("pageRange", listOf(pageRange.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/wordcounter", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * Convert XFA Format to Another Format.
     * Converts XFA documents to the specified format, ensuring seamless compatibility and usability. This service supports a wide range of target formats, allowing users to choose the most suitable format for their specific needs. The conversion process maintains the integrity of the original document while adapting it to the desired format, making it ideal for editing, sharing, or archiving..
     * @param files  (optional)
     * @param documentPassword  (optional)
     * @param inputType The format of the input files. (optional)
     * @return FileResponse
     */
    @Suppress("UNCHECKED_CAST")
    fun pdfWebapiXfaconvertPost(files: kotlin.Array<kotlin.Array<kotlin.Byte>>? = null, documentPassword: kotlin.String? = null, inputType: kotlin.String? = null): FileResponse {
        val localVariableBody: kotlin.Any? = mapOf("files" to "$files", "documentPassword" to "$documentPassword")
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (inputType != null) {
                put("inputType", listOf(inputType.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "text/plain, application/json, text/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/pdf/webapi/xfaconvert", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<FileResponse>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FileResponse
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
