/**
 * Aspose.Pdf RestApi
 * Aspose.Pdf RestApi provides a comprehensive set of endpoints for various PDF-related tasks, enabling efficient document processing and manipulation. Users can retrieve processing status, download files, manage file locks, parse documents, redact sensitive information, convert between formats, merge files, add watermarks, perform text searches, and much more. With endpoints for tasks like electronic signing, document comparison, and form filling, the API offers extensive functionality to cater to diverse PDF requirements.
 *
 * OpenAPI spec version: v1
 * Contact: Evgeny.Pirogov@aspose.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { CompressType } from '../model/compressType';
import { FileResponse } from '../model/fileResponse';
import { HashAlgorithm } from '../model/hashAlgorithm';
import { MergeImageType } from '../model/mergeImageType';
import { MetadataOperation } from '../model/metadataOperation';
import { PageNumberHorizontalAlign } from '../model/pageNumberHorizontalAlign';
import { PageNumberVerticalAlign } from '../model/pageNumberVerticalAlign';
import { PageSize } from '../model/pageSize';
import { ResizePageSize } from '../model/resizePageSize';
import { ResizePresetSize } from '../model/resizePresetSize';
import { ResizePresetType } from '../model/resizePresetType';
import { ResizeType } from '../model/resizeType';
import { RotateAngle } from '../model/rotateAngle';
import { RotateType } from '../model/rotateType';
import { SignatureType } from '../model/signatureType';
import { SplitDocType } from '../model/splitDocType';
import { SplitImageType } from '../model/splitImageType';
import { WatermarkType } from '../model/watermarkType';
import { XmlType } from '../model/xmlType';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ApiService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add page numbers to document.
     * Adds page numbers to the provided documents with the specified alignment, starting number, and format.
     * @param files 
     * @param vAlignment The vertical alignment of the page numbers.
     * @param hAlignment The horizontal alignment of the page numbers.
     * @param startingNumber The starting number for the page numbers.
     * @param sNumber The number of the first page to start numbering from.
     * @param fNumber The number of the last page to end numbering at.
     * @param margin The margin around the page numbers.
     * @param fontSize The font size of the page numbers.
     * @param format The format of the page numbers.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiAddnumberPostForm(files?: Array<Blob>, vAlignment?: PageNumberVerticalAlign, hAlignment?: PageNumberHorizontalAlign, startingNumber?: number, sNumber?: number, fNumber?: number, margin?: number, fontSize?: number, format?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiAddnumberPostForm(files?: Array<Blob>, vAlignment?: PageNumberVerticalAlign, hAlignment?: PageNumberHorizontalAlign, startingNumber?: number, sNumber?: number, fNumber?: number, margin?: number, fontSize?: number, format?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiAddnumberPostForm(files?: Array<Blob>, vAlignment?: PageNumberVerticalAlign, hAlignment?: PageNumberHorizontalAlign, startingNumber?: number, sNumber?: number, fNumber?: number, margin?: number, fontSize?: number, format?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiAddnumberPostForm(files?: Array<Blob>, vAlignment?: PageNumberVerticalAlign, hAlignment?: PageNumberHorizontalAlign, startingNumber?: number, sNumber?: number, fNumber?: number, margin?: number, fontSize?: number, format?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (vAlignment !== undefined && vAlignment !== null) {
            queryParameters = queryParameters.set('vAlignment', <any>vAlignment);
        }
        if (hAlignment !== undefined && hAlignment !== null) {
            queryParameters = queryParameters.set('hAlignment', <any>hAlignment);
        }
        if (startingNumber !== undefined && startingNumber !== null) {
            queryParameters = queryParameters.set('startingNumber', <any>startingNumber);
        }
        if (sNumber !== undefined && sNumber !== null) {
            queryParameters = queryParameters.set('sNumber', <any>sNumber);
        }
        if (fNumber !== undefined && fNumber !== null) {
            queryParameters = queryParameters.set('fNumber', <any>fNumber);
        }
        if (margin !== undefined && margin !== null) {
            queryParameters = queryParameters.set('margin', <any>margin);
        }
        if (fontSize !== undefined && fontSize !== null) {
            queryParameters = queryParameters.set('fontSize', <any>fontSize);
        }
        if (format !== undefined && format !== null) {
            queryParameters = queryParameters.set('format', <any>format);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/addnumber`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param fontReplacementsJson 
     * @param files 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiChangeFontsPostForm(fontReplacementsJson?: string, files?: Array<Blob>, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiChangeFontsPostForm(fontReplacementsJson?: string, files?: Array<Blob>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiChangeFontsPostForm(fontReplacementsJson?: string, files?: Array<Blob>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiChangeFontsPostForm(fontReplacementsJson?: string, files?: Array<Blob>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (fontReplacementsJson !== undefined) {
            formParams = formParams.append('fontReplacementsJson', <any>fontReplacementsJson) as any || formParams;
        }
        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/change-fonts`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Compare documents text.
     * Compare provided files and create document with marked changes.
     * @param files 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiComparisonPostForm(files?: Array<Blob>, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiComparisonPostForm(files?: Array<Blob>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiComparisonPostForm(files?: Array<Blob>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiComparisonPostForm(files?: Array<Blob>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/comparison`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Compress document.
     * Compresses the provided files using the specified compression level.
     * @param files 
     * @param compressType The level of compression to use.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiCompressPostForm(files?: Array<Blob>, compressType?: CompressType, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiCompressPostForm(files?: Array<Blob>, compressType?: CompressType, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiCompressPostForm(files?: Array<Blob>, compressType?: CompressType, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiCompressPostForm(files?: Array<Blob>, compressType?: CompressType, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (compressType !== undefined && compressType !== null) {
            queryParameters = queryParameters.set('compressType', <any>compressType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/compress`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Convert document to another format.
     * Converts the provided files from one format to another.
     * @param files 
     * @param inputType The format of the input files.
     * @param outputType The desired format for the output files.
     * @param xmlType The type of XML conversion to perform, if applicable.
     * @param xmlTag The XML tag to use for conversion, if applicable.
     * @param fontSise 
     * @param isToSingle Indicates whether the conversion should result in a single file, if applicable.
     * @param separator The separator to use when converting, if applicable.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiConvertPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, xmlType?: XmlType, xmlTag?: string, fontSise?: number, isToSingle?: boolean, separator?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiConvertPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, xmlType?: XmlType, xmlTag?: string, fontSise?: number, isToSingle?: boolean, separator?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiConvertPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, xmlType?: XmlType, xmlTag?: string, fontSise?: number, isToSingle?: boolean, separator?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiConvertPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, xmlType?: XmlType, xmlTag?: string, fontSise?: number, isToSingle?: boolean, separator?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }
        if (xmlType !== undefined && xmlType !== null) {
            queryParameters = queryParameters.set('xmlType', <any>xmlType);
        }
        if (xmlTag !== undefined && xmlTag !== null) {
            queryParameters = queryParameters.set('xmlTag', <any>xmlTag);
        }
        if (fontSise !== undefined && fontSise !== null) {
            queryParameters = queryParameters.set('fontSise', <any>fontSise);
        }
        if (isToSingle !== undefined && isToSingle !== null) {
            queryParameters = queryParameters.set('isToSingle', <any>isToSingle);
        }
        if (separator !== undefined && separator !== null) {
            queryParameters = queryParameters.set('separator', <any>separator);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/convert`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Convert web page to document.
     * Converts a web page to the specified output format.
     * @param webPage 
     * @param outputType The desired format for the output file.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiConvertWebpagePostForm(webPage?: string, outputType?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiConvertWebpagePostForm(webPage?: string, outputType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiConvertWebpagePostForm(webPage?: string, outputType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiConvertWebpagePostForm(webPage?: string, outputType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (webPage !== undefined) {
            formParams = formParams.append('webPage', <any>webPage) as any || formParams;
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/convert-webpage`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crop document.
     * Crops the provided files to the specified dimensions.
     * @param files 
     * @param inputType The format of the input files.
     * @param top The number of pixels to crop from the top.
     * @param right The number of pixels to crop from the right.
     * @param bottom The number of pixels to crop from the bottom.
     * @param left The number of pixels to crop from the left.
     * @param outputType The desired format for the output files.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiCropPostForm(files?: Array<Blob>, inputType?: string, top?: number, right?: number, bottom?: number, left?: number, outputType?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiCropPostForm(files?: Array<Blob>, inputType?: string, top?: number, right?: number, bottom?: number, left?: number, outputType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiCropPostForm(files?: Array<Blob>, inputType?: string, top?: number, right?: number, bottom?: number, left?: number, outputType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiCropPostForm(files?: Array<Blob>, inputType?: string, top?: number, right?: number, bottom?: number, left?: number, outputType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }
        if (top !== undefined && top !== null) {
            queryParameters = queryParameters.set('top', <any>top);
        }
        if (right !== undefined && right !== null) {
            queryParameters = queryParameters.set('right', <any>right);
        }
        if (bottom !== undefined && bottom !== null) {
            queryParameters = queryParameters.set('bottom', <any>bottom);
        }
        if (left !== undefined && left !== null) {
            queryParameters = queryParameters.set('left', <any>left);
        }
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/crop`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * File download.
     * Downloads processed file.
     * @param id The id of the processing to download.
     * @param file The name of the file to download.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiDownloadIdGet(id: string, file?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public pdfWebapiDownloadIdGet(id: string, file?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public pdfWebapiDownloadIdGet(id: string, file?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public pdfWebapiDownloadIdGet(id: string, file?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling pdfWebapiDownloadIdGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (file !== undefined && file !== null) {
            queryParameters = queryParameters.set('file', <any>file);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/pdf/webapi/download/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sign document with certificate.
     * Electronically signs the provided documents with the specified certificate.
     * @param passw 
     * @param files 
     * @param inputType The format of the input files.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiEsignPostForm(passw?: string, files?: Array<Blob>, inputType?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiEsignPostForm(passw?: string, files?: Array<Blob>, inputType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiEsignPostForm(passw?: string, files?: Array<Blob>, inputType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiEsignPostForm(passw?: string, files?: Array<Blob>, inputType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (passw !== undefined) {
            formParams = formParams.append('passw', <any>passw) as any || formParams;
        }
        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/esign`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Extract tables from document.
     * Extracts tables from the provided documents and converts them to the specified output format.
     * @param files 
     * @param inputType The format of the input files.
     * @param outputType The desired format for the output files.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiExtractPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiExtractPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiExtractPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiExtractPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/extract`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fill form.
     * Fills a form with the provided files.
     * @param files 
     * @param fileName The name of the file to fill the form with.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiFormFillerPostForm(files?: Array<Blob>, fileName?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiFormFillerPostForm(files?: Array<Blob>, fileName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiFormFillerPostForm(files?: Array<Blob>, fileName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiFormFillerPostForm(files?: Array<Blob>, fileName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fileName !== undefined && fileName !== null) {
            queryParameters = queryParameters.set('fileName', <any>fileName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/form-filler`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Make GIF.
     * Creates a GIF from the provided images.
     * @param files 
     * @param keepImagesAsIs Indicates whether the images should be kept as is.
     * @param resizeToImage The index of the image to resize the other images to.
     * @param streched 
     * @param width The width of the GIF.
     * @param height The height of the GIF.
     * @param frameTimes The times for each frame in the GIF.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiGifPostForm(files?: Array<Blob>, keepImagesAsIs?: boolean, resizeToImage?: number, streched?: boolean, width?: number, height?: number, frameTimes?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiGifPostForm(files?: Array<Blob>, keepImagesAsIs?: boolean, resizeToImage?: number, streched?: boolean, width?: number, height?: number, frameTimes?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiGifPostForm(files?: Array<Blob>, keepImagesAsIs?: boolean, resizeToImage?: number, streched?: boolean, width?: number, height?: number, frameTimes?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiGifPostForm(files?: Array<Blob>, keepImagesAsIs?: boolean, resizeToImage?: number, streched?: boolean, width?: number, height?: number, frameTimes?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (keepImagesAsIs !== undefined && keepImagesAsIs !== null) {
            queryParameters = queryParameters.set('keepImagesAsIs', <any>keepImagesAsIs);
        }
        if (resizeToImage !== undefined && resizeToImage !== null) {
            queryParameters = queryParameters.set('resizeToImage', <any>resizeToImage);
        }
        if (streched !== undefined && streched !== null) {
            queryParameters = queryParameters.set('streched', <any>streched);
        }
        if (width !== undefined && width !== null) {
            queryParameters = queryParameters.set('width', <any>width);
        }
        if (height !== undefined && height !== null) {
            queryParameters = queryParameters.set('height', <any>height);
        }
        if (frameTimes !== undefined && frameTimes !== null) {
            queryParameters = queryParameters.set('frameTimes', <any>frameTimes);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/gif`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Calculate document hash.
     * Calculate hashes of provided files using the specified algorithm.
     * @param files 
     * @param inputType The format of the input files.
     * @param outputType The desired format for the output files.
     * @param alg The hashing algorithm to use.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiHashPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, alg?: HashAlgorithm, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiHashPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, alg?: HashAlgorithm, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiHashPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, alg?: HashAlgorithm, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiHashPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, alg?: HashAlgorithm, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }
        if (alg !== undefined && alg !== null) {
            queryParameters = queryParameters.set('alg', <any>alg);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/hash`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Lock document.
     * Locks a document with the provided password and optional files.
     * @param files 
     * @param passw The password required to lock the resource.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiLockPostForm(files?: Array<Blob>, passw?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiLockPostForm(files?: Array<Blob>, passw?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiLockPostForm(files?: Array<Blob>, passw?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiLockPostForm(files?: Array<Blob>, passw?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (passw !== undefined && passw !== null) {
            queryParameters = queryParameters.set('passw', <any>passw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/lock`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Merge documents.
     * Merges the provided files into a single document or image, with options for orientation and page size.
     * @param files 
     * @param inputType The format of the input files.
     * @param outputType The desired format for the output file.
     * @param mergeType Type of merger operation.
     * @param horizontal The number of images to merge horizontally, if applicable.
     * @param vertical The number of images to merge vertically, if applicable.
     * @param pageSize The page size for the output file, if applicable.
     * @param dcIsLandscape Indicates whether the output file should be in landscape orientation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiMergePostForm(files?: Array<Blob>, inputType?: string, outputType?: string, mergeType?: MergeImageType, horizontal?: number, vertical?: number, pageSize?: PageSize, dcIsLandscape?: boolean, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiMergePostForm(files?: Array<Blob>, inputType?: string, outputType?: string, mergeType?: MergeImageType, horizontal?: number, vertical?: number, pageSize?: PageSize, dcIsLandscape?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiMergePostForm(files?: Array<Blob>, inputType?: string, outputType?: string, mergeType?: MergeImageType, horizontal?: number, vertical?: number, pageSize?: PageSize, dcIsLandscape?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiMergePostForm(files?: Array<Blob>, inputType?: string, outputType?: string, mergeType?: MergeImageType, horizontal?: number, vertical?: number, pageSize?: PageSize, dcIsLandscape?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }
        if (mergeType !== undefined && mergeType !== null) {
            queryParameters = queryParameters.set('mergeType', <any>mergeType);
        }
        if (horizontal !== undefined && horizontal !== null) {
            queryParameters = queryParameters.set('horizontal', <any>horizontal);
        }
        if (vertical !== undefined && vertical !== null) {
            queryParameters = queryParameters.set('vertical', <any>vertical);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (dcIsLandscape !== undefined && dcIsLandscape !== null) {
            queryParameters = queryParameters.set('dc_isLandscape', <any>dcIsLandscape);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/merge`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Read and change document metadata.
     * Performs metadata operations on the provided files.
     * @param files 
     * @param operation The operation to perform on the metadata.
     * @param folder The folder where the files are located.
     * @param name The name of the file to perform the operation on.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiMetadataPostForm(files?: Array<Blob>, operation?: MetadataOperation, folder?: string, name?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiMetadataPostForm(files?: Array<Blob>, operation?: MetadataOperation, folder?: string, name?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiMetadataPostForm(files?: Array<Blob>, operation?: MetadataOperation, folder?: string, name?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiMetadataPostForm(files?: Array<Blob>, operation?: MetadataOperation, folder?: string, name?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (operation !== undefined && operation !== null) {
            queryParameters = queryParameters.set('operation', <any>operation);
        }
        if (folder !== undefined && folder !== null) {
            queryParameters = queryParameters.set('folder', <any>folder);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/metadata`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Organize document pages.
     * Organizes the provided documents by removing or moving specified pages.
     * @param files 
     * @param inputType The format of the input files.
     * @param remove The pages to remove from the document.
     * @param move The pages to move within the document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiOrganizePostForm(files?: Array<Blob>, inputType?: string, remove?: string, move?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiOrganizePostForm(files?: Array<Blob>, inputType?: string, remove?: string, move?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiOrganizePostForm(files?: Array<Blob>, inputType?: string, remove?: string, move?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiOrganizePostForm(files?: Array<Blob>, inputType?: string, remove?: string, move?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }
        if (remove !== undefined && remove !== null) {
            queryParameters = queryParameters.set('remove', <any>remove);
        }
        if (move !== undefined && move !== null) {
            queryParameters = queryParameters.set('move', <any>move);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/organize`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Parse document.
     * Parses the provided files using a parser service.
     * @param files 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiParsePostForm(files?: Array<Blob>, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiParsePostForm(files?: Array<Blob>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiParsePostForm(files?: Array<Blob>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiParsePostForm(files?: Array<Blob>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/parse`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Redact document text.
     * Redacts specified text from the provided documents, with options to search case-sensitively, target in text, comments, and metadata.
     * @param files 
     * @param searchQuery The text to search for and redact.
     * @param replaceText The text to replace the found text with.
     * @param caseSensitive Indicates whether the search should be case-sensitive.
     * @param text Indicates whether text should be redacted.
     * @param comments Indicates whether comments should be redacted.
     * @param metadata Indicates whether metadata should be redacted.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiRedactPostForm(files?: Array<Blob>, searchQuery?: string, replaceText?: string, caseSensitive?: boolean, text?: boolean, comments?: boolean, metadata?: boolean, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiRedactPostForm(files?: Array<Blob>, searchQuery?: string, replaceText?: string, caseSensitive?: boolean, text?: boolean, comments?: boolean, metadata?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiRedactPostForm(files?: Array<Blob>, searchQuery?: string, replaceText?: string, caseSensitive?: boolean, text?: boolean, comments?: boolean, metadata?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiRedactPostForm(files?: Array<Blob>, searchQuery?: string, replaceText?: string, caseSensitive?: boolean, text?: boolean, comments?: boolean, metadata?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (searchQuery !== undefined && searchQuery !== null) {
            queryParameters = queryParameters.set('searchQuery', <any>searchQuery);
        }
        if (replaceText !== undefined && replaceText !== null) {
            queryParameters = queryParameters.set('replaceText', <any>replaceText);
        }
        if (caseSensitive !== undefined && caseSensitive !== null) {
            queryParameters = queryParameters.set('caseSensitive', <any>caseSensitive);
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (comments !== undefined && comments !== null) {
            queryParameters = queryParameters.set('comments', <any>comments);
        }
        if (metadata !== undefined && metadata !== null) {
            queryParameters = queryParameters.set('metadata', <any>metadata);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/redact`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove stored files.
     * Removes processed files from storage.
     * @param id The ID of the processing to remove.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiRemoveIdPost(id: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiRemoveIdPost(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiRemoveIdPost(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiRemoveIdPost(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling pdfWebapiRemoveIdPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/remove/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove document annotations.
     * Removes annotations from the provided documents.
     * @param files 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiRemovePostForm(files?: Array<Blob>, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiRemovePostForm(files?: Array<Blob>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiRemovePostForm(files?: Array<Blob>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiRemovePostForm(files?: Array<Blob>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/remove`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes document watermark.
     * Removes a watermark from the document pages.
     * @param watermarkText 
     * @param top 
     * @param left 
     * @param bottom 
     * @param right 
     * @param files 
     * @param isAllPages Indicates whether the watermark should be removed from all pages.
     * @param watermarkType The type of watermark to remove.
     * @param removeRange The range of pages to remove the watermark from.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiRemoveWatermarkPostForm(watermarkText?: string, top?: number, left?: number, bottom?: number, right?: number, files?: Array<Blob>, isAllPages?: boolean, watermarkType?: WatermarkType, removeRange?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiRemoveWatermarkPostForm(watermarkText?: string, top?: number, left?: number, bottom?: number, right?: number, files?: Array<Blob>, isAllPages?: boolean, watermarkType?: WatermarkType, removeRange?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiRemoveWatermarkPostForm(watermarkText?: string, top?: number, left?: number, bottom?: number, right?: number, files?: Array<Blob>, isAllPages?: boolean, watermarkType?: WatermarkType, removeRange?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiRemoveWatermarkPostForm(watermarkText?: string, top?: number, left?: number, bottom?: number, right?: number, files?: Array<Blob>, isAllPages?: boolean, watermarkType?: WatermarkType, removeRange?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (isAllPages !== undefined && isAllPages !== null) {
            queryParameters = queryParameters.set('isAllPages', <any>isAllPages);
        }
        if (watermarkType !== undefined && watermarkType !== null) {
            queryParameters = queryParameters.set('watermarkType', <any>watermarkType);
        }
        if (removeRange !== undefined && removeRange !== null) {
            queryParameters = queryParameters.set('removeRange', <any>removeRange);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (watermarkText !== undefined) {
            formParams = formParams.append('watermarkText', <any>watermarkText) as any || formParams;
        }
        if (top !== undefined) {
            formParams = formParams.append('top', <any>top) as any || formParams;
        }
        if (left !== undefined) {
            formParams = formParams.append('left', <any>left) as any || formParams;
        }
        if (bottom !== undefined) {
            formParams = formParams.append('bottom', <any>bottom) as any || formParams;
        }
        if (right !== undefined) {
            formParams = formParams.append('right', <any>right) as any || formParams;
        }
        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/remove-watermark`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove pages from document.
     * Removes specified pages from the provided files.
     * @param files 
     * @param removeRange The range of pages to remove from the files.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiRemovepagesPostForm(files?: Array<Blob>, removeRange?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiRemovepagesPostForm(files?: Array<Blob>, removeRange?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiRemovepagesPostForm(files?: Array<Blob>, removeRange?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiRemovepagesPostForm(files?: Array<Blob>, removeRange?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (removeRange !== undefined && removeRange !== null) {
            queryParameters = queryParameters.set('removeRange', <any>removeRange);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/removepages`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Repair document.
     * Repairs the provided files.
     * @param files 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiRepairPostForm(files?: Array<Blob>, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiRepairPostForm(files?: Array<Blob>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiRepairPostForm(files?: Array<Blob>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiRepairPostForm(files?: Array<Blob>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/repair`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Resize document.
     * Resizes the provided files to the specified dimensions or using a preset size.
     * @param files 
     * @param inputType The format of the input files.
     * @param outputType The desired format for the output files.
     * @param resizeType The type of resizing to apply.
     * @param presetType The type of preset size to use for resizing.
     * @param presetSize The preset size to use for resizing.
     * @param width The desired width of the resized files.
     * @param height The desired height of the resized files.
     * @param percentage The percentage to resize the files by.
     * @param useProportions Indicates whether to maintain the aspect ratio when resizing.
     * @param pageSize The page size to use for the resized files.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiResizePostForm(files?: Array<Blob>, inputType?: string, outputType?: string, resizeType?: ResizeType, presetType?: ResizePresetType, presetSize?: ResizePresetSize, width?: number, height?: number, percentage?: number, useProportions?: boolean, pageSize?: ResizePageSize, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiResizePostForm(files?: Array<Blob>, inputType?: string, outputType?: string, resizeType?: ResizeType, presetType?: ResizePresetType, presetSize?: ResizePresetSize, width?: number, height?: number, percentage?: number, useProportions?: boolean, pageSize?: ResizePageSize, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiResizePostForm(files?: Array<Blob>, inputType?: string, outputType?: string, resizeType?: ResizeType, presetType?: ResizePresetType, presetSize?: ResizePresetSize, width?: number, height?: number, percentage?: number, useProportions?: boolean, pageSize?: ResizePageSize, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiResizePostForm(files?: Array<Blob>, inputType?: string, outputType?: string, resizeType?: ResizeType, presetType?: ResizePresetType, presetSize?: ResizePresetSize, width?: number, height?: number, percentage?: number, useProportions?: boolean, pageSize?: ResizePageSize, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }
        if (resizeType !== undefined && resizeType !== null) {
            queryParameters = queryParameters.set('resizeType', <any>resizeType);
        }
        if (presetType !== undefined && presetType !== null) {
            queryParameters = queryParameters.set('presetType', <any>presetType);
        }
        if (presetSize !== undefined && presetSize !== null) {
            queryParameters = queryParameters.set('presetSize', <any>presetSize);
        }
        if (width !== undefined && width !== null) {
            queryParameters = queryParameters.set('width', <any>width);
        }
        if (height !== undefined && height !== null) {
            queryParameters = queryParameters.set('height', <any>height);
        }
        if (percentage !== undefined && percentage !== null) {
            queryParameters = queryParameters.set('percentage', <any>percentage);
        }
        if (useProportions !== undefined && useProportions !== null) {
            queryParameters = queryParameters.set('useProportions', <any>useProportions);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/resize`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Rotate document.
     * Rotates the provided files by a specified angle, with options for rotation type and page number.
     * @param files 
     * @param angle The angle by which to rotate the files.
     * @param rotateType The type of rotation to perform.
     * @param pageNum The page number to rotate, if applicable.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiRotatePostForm(files?: Array<Blob>, angle?: RotateAngle, rotateType?: RotateType, pageNum?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiRotatePostForm(files?: Array<Blob>, angle?: RotateAngle, rotateType?: RotateType, pageNum?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiRotatePostForm(files?: Array<Blob>, angle?: RotateAngle, rotateType?: RotateType, pageNum?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiRotatePostForm(files?: Array<Blob>, angle?: RotateAngle, rotateType?: RotateType, pageNum?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (angle !== undefined && angle !== null) {
            queryParameters = queryParameters.set('angle', <any>angle);
        }
        if (rotateType !== undefined && rotateType !== null) {
            queryParameters = queryParameters.set('rotateType', <any>rotateType);
        }
        if (pageNum !== undefined && pageNum !== null) {
            queryParameters = queryParameters.set('pageNum', <any>pageNum);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/rotate`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search document text.
     * Searches the provided files for the specified query and makr found text with yellow background.
     * @param files 
     * @param query The text to search for within the files.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiSearchPostForm(files?: Array<Blob>, query?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiSearchPostForm(files?: Array<Blob>, query?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiSearchPostForm(files?: Array<Blob>, query?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiSearchPostForm(files?: Array<Blob>, query?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (query !== undefined && query !== null) {
            queryParameters = queryParameters.set('query', <any>query);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/search`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Make scanned pdf searchable.
     * Converts the provided files into a searchable PDF format for the specified language.
     * @param files 
     * @param lang The language of the files to be converted.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiSearchablePostForm(files?: Array<Blob>, lang?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiSearchablePostForm(files?: Array<Blob>, lang?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiSearchablePostForm(files?: Array<Blob>, lang?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiSearchablePostForm(files?: Array<Blob>, lang?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (lang !== undefined && lang !== null) {
            queryParameters = queryParameters.set('lang', <any>lang);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/searchable`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add signature to document.
     * Adds a signature, text and image to the provided documents.
     * @param image 
     * @param text 
     * @param textColor 
     * @param files 
     * @param inputType The format of the input files.
     * @param outputType The desired format for the output files.
     * @param signatureType The type of signature to add.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiSignaturePostForm(image?: string, text?: string, textColor?: string, files?: Array<Blob>, inputType?: string, outputType?: string, signatureType?: SignatureType, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiSignaturePostForm(image?: string, text?: string, textColor?: string, files?: Array<Blob>, inputType?: string, outputType?: string, signatureType?: SignatureType, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiSignaturePostForm(image?: string, text?: string, textColor?: string, files?: Array<Blob>, inputType?: string, outputType?: string, signatureType?: SignatureType, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiSignaturePostForm(image?: string, text?: string, textColor?: string, files?: Array<Blob>, inputType?: string, outputType?: string, signatureType?: SignatureType, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {








        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }
        if (signatureType !== undefined && signatureType !== null) {
            queryParameters = queryParameters.set('signatureType', <any>signatureType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (image !== undefined) {
            formParams = formParams.append('image', <any>image) as any || formParams;
        }
        if (text !== undefined) {
            formParams = formParams.append('text', <any>text) as any || formParams;
        }
        if (textColor !== undefined) {
            formParams = formParams.append('textColor', <any>textColor) as any || formParams;
        }
        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/signature`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Split document.
     * Splits the provided documents based on the specified split type and page rage to spit.
     * @param files 
     * @param splitType The type of splitting to be performed.
     * @param pairs Optional page rage for the splitting operation.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiSplitdocPostForm(files?: Array<Blob>, splitType?: SplitDocType, pairs?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiSplitdocPostForm(files?: Array<Blob>, splitType?: SplitDocType, pairs?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiSplitdocPostForm(files?: Array<Blob>, splitType?: SplitDocType, pairs?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiSplitdocPostForm(files?: Array<Blob>, splitType?: SplitDocType, pairs?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (splitType !== undefined && splitType !== null) {
            queryParameters = queryParameters.set('splitType', <any>splitType);
        }
        if (pairs !== undefined && pairs !== null) {
            queryParameters = queryParameters.set('pairs', <any>pairs);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/splitdoc`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Split image.
     * Splits the provided images into smaller parts based on the specified parameters.
     * @param files 
     * @param splitType The type of splitting to be performed.
     * @param vertical The number of vertical splits to create.
     * @param horizontal The number of horizontal splits to create.
     * @param outputType The desired output format for the split images.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiSplitimagePostForm(files?: Array<Blob>, splitType?: SplitImageType, vertical?: number, horizontal?: number, outputType?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiSplitimagePostForm(files?: Array<Blob>, splitType?: SplitImageType, vertical?: number, horizontal?: number, outputType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiSplitimagePostForm(files?: Array<Blob>, splitType?: SplitImageType, vertical?: number, horizontal?: number, outputType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiSplitimagePostForm(files?: Array<Blob>, splitType?: SplitImageType, vertical?: number, horizontal?: number, outputType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (splitType !== undefined && splitType !== null) {
            queryParameters = queryParameters.set('splitType', <any>splitType);
        }
        if (vertical !== undefined && vertical !== null) {
            queryParameters = queryParameters.set('vertical', <any>vertical);
        }
        if (horizontal !== undefined && horizontal !== null) {
            queryParameters = queryParameters.set('horizontal', <any>horizontal);
        }
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/splitimage`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Processing status.
     * Retrieves the status of a processing.
     * @param id The ID of the processing to check the status of.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiStatusIdPost(id: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiStatusIdPost(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiStatusIdPost(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiStatusIdPost(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling pdfWebapiStatusIdPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/status/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Unlock document.
     * Attempts to unlock a document with an password and associated files.
     * @param files 
     * @param passw The password used in locked document.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiUnlockPostForm(files?: Array<Blob>, passw?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiUnlockPostForm(files?: Array<Blob>, passw?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiUnlockPostForm(files?: Array<Blob>, passw?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiUnlockPostForm(files?: Array<Blob>, passw?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (passw !== undefined && passw !== null) {
            queryParameters = queryParameters.set('passw', <any>passw);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/unlock`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Verify document certificate.
     * Verifies the electronic signature of the provided files.
     * @param files 
     * @param inputType The format of the input files.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiVerifyEsignPostForm(files?: Array<Blob>, inputType?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiVerifyEsignPostForm(files?: Array<Blob>, inputType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiVerifyEsignPostForm(files?: Array<Blob>, inputType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiVerifyEsignPostForm(files?: Array<Blob>, inputType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/verify_esign`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add watermark to document.
     * Adds a watermark to the provided files.
     * @param files 
     * @param inputType The format of the input files.
     * @param outputType The desired format for the output files.
     * @param isColored Indicate is watermark will be in color or grayscale.
     * @param isText Indicates whether the watermark is text.
     * @param text The text of the watermark.
     * @param name The name of the font for the text watermark.
     * @param size The size of the font for the text watermark.
     * @param bold Indicates whether the text watermark is bold.
     * @param italic Indicates whether the text watermark is italic.
     * @param underlined Indicates whether the text watermark is underlined.
     * @param color The color of the text or image watermark.
     * @param isBackground Indicates whether the watermark is a background watermark.
     * @param rotation The rotation angle of the watermark.
     * @param transparency The transparency of the watermark.
     * @param layer Indicates whether the watermark is a layer.
     * @param pageFrom The starting page number for the watermark.
     * @param pageTo The ending page number for the watermark.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiWatermarkPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, isColored?: boolean, isText?: boolean, text?: string, name?: string, size?: number, bold?: boolean, italic?: boolean, underlined?: boolean, color?: string, isBackground?: boolean, rotation?: number, transparency?: number, layer?: boolean, pageFrom?: number, pageTo?: number, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiWatermarkPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, isColored?: boolean, isText?: boolean, text?: string, name?: string, size?: number, bold?: boolean, italic?: boolean, underlined?: boolean, color?: string, isBackground?: boolean, rotation?: number, transparency?: number, layer?: boolean, pageFrom?: number, pageTo?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiWatermarkPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, isColored?: boolean, isText?: boolean, text?: string, name?: string, size?: number, bold?: boolean, italic?: boolean, underlined?: boolean, color?: string, isBackground?: boolean, rotation?: number, transparency?: number, layer?: boolean, pageFrom?: number, pageTo?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiWatermarkPostForm(files?: Array<Blob>, inputType?: string, outputType?: string, isColored?: boolean, isText?: boolean, text?: string, name?: string, size?: number, bold?: boolean, italic?: boolean, underlined?: boolean, color?: string, isBackground?: boolean, rotation?: number, transparency?: number, layer?: boolean, pageFrom?: number, pageTo?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }
        if (outputType !== undefined && outputType !== null) {
            queryParameters = queryParameters.set('outputType', <any>outputType);
        }
        if (isColored !== undefined && isColored !== null) {
            queryParameters = queryParameters.set('isColored', <any>isColored);
        }
        if (isText !== undefined && isText !== null) {
            queryParameters = queryParameters.set('isText', <any>isText);
        }
        if (text !== undefined && text !== null) {
            queryParameters = queryParameters.set('text', <any>text);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (bold !== undefined && bold !== null) {
            queryParameters = queryParameters.set('bold', <any>bold);
        }
        if (italic !== undefined && italic !== null) {
            queryParameters = queryParameters.set('italic', <any>italic);
        }
        if (underlined !== undefined && underlined !== null) {
            queryParameters = queryParameters.set('underlined', <any>underlined);
        }
        if (color !== undefined && color !== null) {
            queryParameters = queryParameters.set('color', <any>color);
        }
        if (isBackground !== undefined && isBackground !== null) {
            queryParameters = queryParameters.set('isBackground', <any>isBackground);
        }
        if (rotation !== undefined && rotation !== null) {
            queryParameters = queryParameters.set('rotation', <any>rotation);
        }
        if (transparency !== undefined && transparency !== null) {
            queryParameters = queryParameters.set('transparency', <any>transparency);
        }
        if (layer !== undefined && layer !== null) {
            queryParameters = queryParameters.set('layer', <any>layer);
        }
        if (pageFrom !== undefined && pageFrom !== null) {
            queryParameters = queryParameters.set('pageFrom', <any>pageFrom);
        }
        if (pageTo !== undefined && pageTo !== null) {
            queryParameters = queryParameters.set('pageTo', <any>pageTo);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/watermark`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Count words and chars in document.
     * Counts the words in the provided files within the specified page range.
     * @param files 
     * @param pageRange The range of pages to count words in.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiWordcounterPostForm(files?: Array<Blob>, pageRange?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiWordcounterPostForm(files?: Array<Blob>, pageRange?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiWordcounterPostForm(files?: Array<Blob>, pageRange?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiWordcounterPostForm(files?: Array<Blob>, pageRange?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageRange !== undefined && pageRange !== null) {
            queryParameters = queryParameters.set('pageRange', <any>pageRange);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/wordcounter`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Convert XFA format to a another format.
     * Converts the provided documents from XFA format to a different format.
     * @param files 
     * @param inputType The format of the input files.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pdfWebapiXfaconvertPostForm(files?: Array<Blob>, inputType?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResponse>;
    public pdfWebapiXfaconvertPostForm(files?: Array<Blob>, inputType?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResponse>>;
    public pdfWebapiXfaconvertPostForm(files?: Array<Blob>, inputType?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResponse>>;
    public pdfWebapiXfaconvertPostForm(files?: Array<Blob>, inputType?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (inputType !== undefined && inputType !== null) {
            queryParameters = queryParameters.set('inputType', <any>inputType);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (files) {
            files.forEach((element) => {
                formParams = formParams.append('files', <any>element) as any || formParams;
            })
        }

        return this.httpClient.request<FileResponse>('post',`${this.basePath}/pdf/webapi/xfaconvert`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
